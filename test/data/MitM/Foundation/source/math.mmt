namespace http://mathhub.info/MitM/Foundation âš

import rules scala://rules.mitm.mmt.kwarc.info âš
import lf scala://lf.mmt.kwarc.info âš
import lfx scala://LFX.mmt.kwarc.info âš


theory Metadata =
	constructorargument â™
âš

/T We define a formal language for basic mathematical objects in LF. âš

theory Subtyping =
	 include http://gl.mathhub.info/MMT/LFX/Subtyping?LFSubtyped â™
âš

/T First, some logic. âš

                                               
theory Logic : http://gl.mathhub.info/MMT/LFX/TypedHierarchy?LFHierarchy =
	 include http://gl.mathhub.info/MMT/LFX/Records?LFRecords â™
	 include http://cds.omdoc.org/urtheories?Ded â™
	 include http://gl.mathhub.info/MMT/LFX/Subtyping?LFWithVariance â™
	 
	 // rule rules?ApplyRule â™
	 
	 /T the type of booleans, i.e., all formulas are represented as terms of LF-type $prop$ â™
	 // bool : type â˜ // = BOOL â™
	 prop : type â˜ @ bool â˜ = BOOL â™
	 
	 /T one LF-type for each formula holding its proofs                 
	 For example, the LF type âŠ¦ 0 â‰ 1 is empty because that formula has no proofs.
	 Axioms are declared as constants of the corresponding type, e.g., a constant of type $âŠ¦ true$ for the axiom of truth.â™
	 ded : prop âŸ¶ type â˜ # âŠ¦ 1 prec -500 â˜ role Judgment â˜ = DED â™
	 ImplicitProof : {A} âŠ¦ A â˜ # ImplicitProof 1 â™
	 rule lf?TermIrrelevanceRule (ded) ([A : prop] ImplicitProof A) â™
	 
	 /T Equality on terms. The type A is left implicit and can be inferred by MMT â™
	 eq : {A:ğ’° 100} A âŸ¶ A âŸ¶ bool â˜ # 2 â‰ 3 prec -5 â˜ role Eq â˜ // = EQUAL â™
	 
	 
	 // coercion : {A : type, P : A âŸ¶ prop,a} âŠ¦ P a âŸ¶ âŸ¨ A | ([x] âŠ¦ P x) âŸ© â˜ # coerce 3 %I4â™
	 // coercion_theorem : {A : type,P : A âŸ¶ prop,a,p : âŠ¦ P a} âŠ¦ eq âŸ¨ A | ([x] âŠ¦ P x) âŸ© (coercion A P a p) a â™
	 
	 rule rules?BooleanLiterals â™
	 
	 // false_is_FALSE : ded (FALSE â‰ false) â™
	 // true_is_TRUE : ded (TRUE â‰ true) â™
	 
	 not  : bool âŸ¶ bool â˜ # Â¬ 1 prec -100 â™
	 neq : {A: ğ’° 100} A âŸ¶ A âŸ¶ prop â˜ # 2 â‰  3 prec -5 â˜ = [A,a,b] Â¬ (a â‰ b) â™

	 and  : bool âŸ¶ bool âŸ¶ boolâ˜# 1 âˆ§ 2 prec -110 â™
	 
	 or : bool âŸ¶ bool âŸ¶ bool â˜# 1 âˆ¨ 2 prec -120 â˜ // = [A,B] Â¬ (Â¬A âˆ§ Â¬ B) â™
	 implies : bool âŸ¶ bool âŸ¶ bool â˜# 1 â‡’ 2 prec -130 â˜ // = [A,B] B âˆ¨ Â¬A â™
	 iff : bool âŸ¶ bool âŸ¶ bool â˜ # 1 â‡” 2 prec -140 â˜// = [A,B] (A â‡’ B) âˆ§ (B â‡’ A) â™
   
	 forall : {A : ğ’° 100} (A âŸ¶ bool) âŸ¶ bool â˜ # âˆ€ 2 prec -100â™
	 exists : {A : ğ’° 100} (A âŸ¶ bool) âŸ¶ bool â˜ # âˆƒ 2 prec -100 â˜// = [A,f] Â¬ âˆ€ [x:A] Â¬ f x â™
	 unique : {A : ğ’° 100} (A âŸ¶ bool) âŸ¶ A âŸ¶ bool â˜ = [A,P,x] âˆ€ [y:A] P y â‡’ y â‰ x â˜ # unique 2 3 â™
	 exists_unique : {A : ğ’° 100} (A âŸ¶ bool) âŸ¶ bool â˜ # âˆƒ! 2 prec -101 â˜ = [A,P] âˆƒ [x] (P x âˆ§ unique P x) â™
   
	 /T Equality on types (semantics missing) â™
	 tpeq : type âŸ¶ type âŸ¶ bool â˜ # 1 â‰â‰ 2 prec -6 â˜ role Eq â™	 		
	 
âš
	 
theory NaturalDeduction : ur:?LF =
	 include ?Logic â™
	 
	 tru_introduction : âŠ¦ true â™
	 fals_elimination : {A} âŠ¦ false âŸ¶ âŠ¦ A â™
	 fals_introduction : {A} âŠ¦ A âŸ¶ âŠ¦ Â¬ A âŸ¶ âŠ¦ false â™
	 
	 forall_elim : {A : ğ’° 100, P : A âŸ¶ bool}âŠ¦ âˆ€ P âŸ¶ {x : A}âŠ¦ P x â˜ # forallE 3 4â™
	 forall_introduction : {A : ğ’° 100, P : A âŸ¶ bool, p : {x : A}âŠ¦P x}âŠ¦ âˆ€[x] P x â˜ # forallI 3 â™

	 and_introduction : {A,B} âŠ¦ A âŸ¶ âŠ¦ B âŸ¶ âŠ¦ (A âˆ§ B) â™
	 and_elim_left : {A,B} âŠ¦ (A âˆ§ B) âŸ¶ âŠ¦ A â™
	 and_elim_right : {A,B} âŠ¦ (A âˆ§ B) âŸ¶ âŠ¦ B â™
	 
	 not_introduction : {A} (âŠ¦ A âŸ¶ âŠ¦ false) âŸ¶ âŠ¦ Â¬ A â™
	 not_elim : {A} âŠ¦ Â¬ Â¬ A âŸ¶ âŠ¦ A â™

	 tnd : {A} âŠ¦ A âˆ¨ Â¬A â˜ // = [A: bool] not_introduction ([p : âŠ¦ (Â¬A âˆ§ Â¬Â¬A)] fals_introduction (not_elim (and_elim_right p)) (and_elim_left p)) â™
	 
	 /T basic axioms governing Equality. Again, all the type parameters can be left implicit â™
	 eq_refl : {t:ğ’° 100,A: t} âŠ¦ A â‰ A â˜ # eq_refl 2â™
	 eq_cong : {t : ğ’° 100, s : ğ’° 100, f : t âŸ¶ s, A : t, B: t}
	 		âŠ¦ A â‰ B âŸ¶ âŠ¦ (f A) â‰ (f B) â˜ # eq_cong 3 6â™
	 
âš
	 

/T Now some theories that introduce primitive types and literals for them.
     Because literals must modify the parser, they are supplied as rules that are implemented in a plugin.âš   
   
theory NatLiterals : ur:?LF =
	include ?Logic â™
	include ?Subtyping â™
	include http://cds.omdoc.org/urtheories?NatLiterals â™
	include http://cds.omdoc.org/urtheories?NatRels â™
	
	nat_lit : type â˜ # â„• â˜ = NAT â™
	// rule rules?NatLiterals â™
	pos_lit : type â˜ = âŸ¨ n : nat_lit | âŠ¦ n â‰  0 âŸ© â˜ # â„•+ â™
	rule rules?PosLiterals â™
	pos_are_nat : pos_lit <* nat_lit â™
	
	succ_nat_lit : nat_lit âŸ¶ pos_lit â™
	rule rules?NatSucc â™
	// not needed anymore: rule rules?NatSuccInverse â™
	
	plus_pos_lit : pos_lit âŸ¶ pos_lit âŸ¶ pos_lit â™
	rule rules?PosPlus â™
	plus_nat_lit : nat_lit âŸ¶ nat_lit âŸ¶ nat_lit â˜ = plus â™
	// rule rules?NatPlus â™
   	times_pos_lit : pos_lit âŸ¶ pos_lit âŸ¶ pos_lit â™
	rule rules?PosTimes â™
	times_nat_lit : nat_lit âŸ¶ nat_lit âŸ¶ nat_lit â˜= times â™
	// rule rules?NatTimes â™
    leq_nat_lit : nat_lit âŸ¶ nat_lit âŸ¶ bool â˜ = LEQ â™
	// rule rules?NatLeq â™
âš
	
theory IntLiterals : ur:?PLF =
	include ?Logic â™
	
	int_lit: type â˜ # â„¤ â™
	rule rules?IntegerLiterals â™
	
	minus_int_lit : int_lit âŸ¶ int_lit â™
	rule rules?IntMinus â™
	plus_int_lit : int_lit âŸ¶ int_lit âŸ¶ int_lit â™
	rule rules?IntPlus â™
  times_int_lit : int_lit âŸ¶ int_lit âŸ¶ int_lit â™
	rule rules?IntTimes â™
  leq_int_lit : int_lit âŸ¶ int_lit âŸ¶ bool â™
	rule rules?IntLeq â™
âš
	
theory RealLiterals : ur:?LF =
	include ?Logic â™
   
	real_lit: type â˜ # â„ â™
	rule rules?RealLiterals â™
	
	leq_real_lit : real_lit âŸ¶ real_lit âŸ¶ bool â™
   	rule rules?RealLeq â™
   	minus_real_lit : real_lit âŸ¶ real_lit  â˜ # - 1 prec 25 â™
   	rule rules?RealMinus â™   
   	plus_real_lit : real_lit âŸ¶ real_lit âŸ¶ real_lit â˜ # 1 + 2 prec 25 â™
	rule rules?RealPlus â™
   	times_real_lit : real_lit âŸ¶ real_lit âŸ¶ real_lit â˜ # 1 Ã— 2 prec 20 â™
	rule rules?RealTimes â™
	
	
	// square_is_pos : {r : â„} âŠ¦ leq_real_lit 0 (times_real_lit r r) â™
	sqrt  : â„ âŸ¶ â„ â™
	rule rules?RealSqrt â™
âš
     
theory Literals : ur:?LF =
   include ?RealLiterals â™
   include ?NatLiterals â™
   include ?IntLiterals â™
   include ?Subtyping â™

   ints_are_real : int_lit <* real_lit â™
   
   nats_are_int : nat_lit <* int_lit â™
   nats_are_real : nat_lit <* real_lit â™
   
   pos_are_int : pos_lit <* int_lit â™
   pos_are_real : pos_lit <* real_lit â™
   
   // rule rules?NumberLiterals â™

   // test : âŠ¦ leq_lit 0 1 â˜ = tru_introduction â™
   // test2 : âŠ¦ nat_lit_succ 1 â‰ 2 â˜ = eq_refl 2 â™
	 
âš
   
theory Trigonometry : ur:?LF =
	include ?RealLiterals â™
	
	tan   : real_lit âŸ¶ real_lit    â™
	sin   : real_lit âŸ¶ real_lit    â™
	cos   : real_lit âŸ¶ real_lit    â™
	atan   : real_lit âŸ¶ real_lit    â™
	asin   : real_lit âŸ¶ real_lit    â™
	acos   : real_lit âŸ¶ real_lit    â™
	
	rule rules?Tan â™
	rule rules?Sin â™
	rule rules?Cos â™
	rule rules?Atan â™
	rule rules?Asin â™
	rule rules?Acos â™
âš
	 
/T String literals are also needed occasionally, e.g., in the LMFDB.âš
 
theory Strings : ur:?LF =
   include ?Logicâ™
   string: type â™
	 rule rules?StringLiterals â™
	 concat: string âŸ¶ string âŸ¶ stringâ™
âš

/T Now some more complex types. First lists.âš

theory Lists : ur:?LF =
   include http://gl.mathhub.info/MMT/LFX/Datatypes?LFLists â™
âš

theory InformalProofs : ur:?LF = 
  include ?Strings â™
   	 
	proofsketch : {A : prop} string âŸ¶ âŠ¦ A â˜ # sketch 2 â™
	byproof : {A,B} âŠ¦ A âŸ¶ âŠ¦ B â˜ # by 3 â™
	addproofstep : {A,B,C: prop} âŠ¦ A âŸ¶ âŠ¦ B âŸ¶ âŠ¦ B â˜ # 4 and 5 â™
	trivial : {A : prop} âŠ¦ A â˜ = [A] sketch "trivial" â˜ # trivial %I1 â™
âš


/T (Finite) sets â™
theory Sets : ur:?LF =
   include ?Logicâ™
   /T the type operator of sets along with its constructorsâ™
   set: type âŸ¶ type â™
   
   empty: {A} (list A) â˜# âˆ… 1â˜## âˆ… %I1 â™
   cons: {A} A âŸ¶ (list A) âŸ¶ (list A)â˜ # 2 , 3 â™ 
âš

/T Multisets â™

/T "Finite hybrid sets" (mutlisets with possibly negative mutliplicities) â™

/T Now vectors, i.e., fixed-length lists.âš

theory Vectors : ur:?PLF =
  include ?Logicâ™
	include ?Literals â™
	
   /T the type operator of vectors (fixed-length lists) over a given type â™
   vector : ğ’° 100 âŸ¶ nat_lit âŸ¶ type â˜ # 1 ^^ 2 prec 32 â™
   
   zerovec : {t : ğ’° 100} vector t 0 â™
   vector_prepend : {t: ğ’° 100,n : nat_lit, a : t, b : vector t n} t ^^ (succ_nat_lit n) â˜ # 3 ; 4â™
âš

theory Matrices : ur:?LF =
  include ?Logicâ™
	include ?Vectors â™
	
  /T the type operator of matrices over a given typeâ™
  matrix : ğ’° 100 âŸ¶ nat_lit âŸ¶ nat_lit âŸ¶ type â˜ = [T,n,m] vector (vector T m) n â™
âš

theory OptionType : ur:?PLF =
	include ?Logic â™
	
	Option : ğ’° 100 âŸ¶ ğ’° 100 â™
	
	isDefined : {A} Option A âŸ¶ prop â˜ # isDefined 2â™
	OptionGet : {A, a : Option A} âŠ¦ isDefined a âŸ¶ A â™
	
	None : {A : ğ’° 100} Option A â˜ # None â™
	None_is_not_Defined : {A : ğ’° 100} âŠ¦ isDefined (None A) â‰ false â™
	Not_None_is_Defined : {A, a : Option A} âŠ¦ (a â‰  None A) âŸ¶ âŠ¦ isDefined a â™
âš

theory DescriptionOperator : ur:?PLF =
	include ?OptionType â™
	
	that : {A:ğ’° 100,P:A âŸ¶ bool} âŠ¦ (âˆƒ! P) âŸ¶  A â˜ # Î¹ 2 %I3 â™
	that_proof : {A : ğ’° 100, P : A âŸ¶ bool, p : âŠ¦ âˆƒ! P} âŠ¦ P (that A P p) â™
	
	if_then_else_exists_proof : {A,P,a:A,b:A} âŠ¦ âˆƒ! [x:A] (P âˆ§ x â‰ a) âˆ¨ (Â¬ P âˆ§ x â‰ b) â˜ # iteep 2 3 4â™
	if_then_else : {A : ğ’° 100, P : bool, a : A, b : A}A â˜ # if 2 then 3 else 4 â˜
		= [A,P,a,b] that A ([x] (P âˆ§ x â‰ a) âˆ¨ (Â¬ P âˆ§ x â‰ b)) (iteep P a b) â™
	if_then_else_case : {A : ğ’° 100, P : bool, a : A, b : A}A â˜ = [A,P,a,b] if P then a else b â˜ # case 2 âŸ¹ 3 . 4 prec 2 â™
	
	if_true : {A : ğ’° 100, P : bool, a : A, b : A, p : âŠ¦ P} âŠ¦ (if P then a else b) â‰ a â˜ // = [A,P,a,b,p] _ â˜ â™
	if_false : {A : ğ’° 100, P : bool, a : A, b : A, p : âŠ¦ Â¬ P } âŠ¦ (if P then a else b) â‰ b â˜ // = [A,P,a,b,p] _ â˜ â™
âš

theory ProductTypes : http://gl.mathhub.info/MMT/LFX/Sigma?LFSigma =
	// to have it in the meta-theory â™                       
âš
theory FiniteTypes : http://gl.mathhub.info/MMT/LFX/Finite?LFFinite = âš
theory InductiveTypes : http://gl.mathhub.info/MMT/LFX/WTypes?Inductive =
    include ?Logic â™
âš

theory Sequences =
	include ur:?Sequences â™
	include ur:?LFS â™
	include ?Logic â™
	
	forall_seq : {A: type}{n} (A^n âŸ¶ prop) âŸ¶ prop â˜ # âˆ€n 3 prec -101 â™
	exists_seq : {A: type}{n} (A^n âŸ¶ prop) âŸ¶ prop â˜ # âˆƒn 3 prec -101 â˜ = [A,n][P] Â¬ forall_seq A n [s : A^n] Â¬ (P s)â™
âš

/T Finally, a theory that puts everything together (not recommended, because modularity) âš

theory Math : ur:?PLF =
	include ?Subtyping â™
	include ?Logic â™
	include ?NaturalDeduction â™
	include ?Literals â™
	include ?Trigonometry â™
	include ?Strings â™
	include ?InformalProofs â™
	include ?Lists â™
	include ?Vectors â™
	include ?Matrices â™
	include ?OptionType â™
	include ?DescriptionOperator â™
	include ?ProductTypes â™
	include ?Sequences â™
âš
