
<!doctype html>
<html>
	<head>
		<meta charset="utf-8">

		<!-- Don't cache! -->
		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
		<meta http-equiv="Pragma" content="no-cache" />
		<meta http-equiv="Expires" content="0">

		<title>Amalgamation of Render Results - mmt-pygments-lexer</title>
	</head>
	<body>
		<h1>Amalgamation of Render Results</h1>
<style>.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */</style><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://rules.mitm.mmt.kwarc.info</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lf</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lfx</span><span class="w"> </span><span class="s">scala://LFX.mmt.kwarc.info</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>


<span class="kd">theory</span><span class="w"> </span><span class="nv">Metadata</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">constructorargument</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">/T We define a formal language for basic mathematical objects in LF. âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Subtyping</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Subtyping?LFSubtyped </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">/T First, some logic. âš</span><span class="w"></span>

<span class="w">                                               </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Logic</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">http://gl.mathhub.info/MMT/LFX/TypedHierarchy?LFHierarchy</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Records?LFRecords </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories?Ded </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Subtyping?LFWithVariance </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">// rule rules?ApplyRule â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">/T the type of booleans, i.e., all formulas are represented as terms of LF-type $prop$ â™</span><span class="w"></span>
<span class="w">	 </span><span class="cm">// bool : type â˜ // = BOOL â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â˜</span><span class="w"> </span><span class="p">@</span><span class="no"> bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">BOOL </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">/T one LF-type for each formula holding its proofs                 </span>
<span class="cm">	 For example, the LF type âŠ¦ 0 â‰ 1 is empty because that formula has no proofs.</span>
<span class="cm">	 Axioms are declared as constants of the corresponding type, e.g., a constant of type $âŠ¦ true$ for the axiom of truth.â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">ded</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">prop âŸ¶ type </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âŠ¦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-500</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Judgment </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">DED </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">ImplicitProof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} âŠ¦ A </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ImplicitProof 1 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">lf?TermIrrelevanceRule (ded) ([A : prop] ImplicitProof A) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">/T Equality on terms. The type A is left implicit and can be inferred by MMT â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:ğ’° 100} A âŸ¶ A âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 â‰ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = EQUAL </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">// coercion : {A : type, P : A âŸ¶ prop,a} âŠ¦ P a âŸ¶ âŸ¨ A | ([x] âŠ¦ P x) âŸ© â˜ # coerce 3 %I4â™</span><span class="w"></span>
<span class="w">	 </span><span class="cm">// coercion_theorem : {A : type,P : A âŸ¶ prop,a,p : âŠ¦ P a} âŠ¦ eq âŸ¨ A | ([x] âŠ¦ P x) âŸ© (coercion A P a p) a â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?BooleanLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">// false_is_FALSE : ded (FALSE â‰ false) â™</span><span class="w"></span>
<span class="w">	 </span><span class="cm">// true_is_TRUE : ded (TRUE â‰ true) â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">not</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Â¬ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">neq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: ğ’° 100} A âŸ¶ A âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 â‰  3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,a,b] Â¬ (a â‰ b) </span><span class="p">â™</span><span class="w"></span>

<span class="w">	 </span><span class="no">and</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ bool âŸ¶ bool</span><span class="p">â˜#</span><span class="s"> 1 âˆ§ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-110</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">or</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ bool âŸ¶ bool </span><span class="p">â˜#</span><span class="s"> 1 âˆ¨ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = [A,B] Â¬ (Â¬A âˆ§ Â¬ B) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">implies</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ bool âŸ¶ bool </span><span class="p">â˜#</span><span class="s"> 1 â‡’ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = [A,B] B âˆ¨ Â¬A </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">iff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ bool âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 â‡” 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140</span><span class="w"> </span><span class="p">â˜</span><span class="cm">// = [A,B] (A â‡’ B) âˆ§ (B â‡’ A) </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	 </span><span class="no">forall</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100} (A âŸ¶ bool) âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆ€ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100</span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">exists</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100} (A âŸ¶ bool) âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆƒ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100</span><span class="w"> </span><span class="p">â˜</span><span class="cm">// = [A,f] Â¬ âˆ€ [x:A] Â¬ f x </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">unique</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100} (A âŸ¶ bool) âŸ¶ A âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P,x] âˆ€ [y:A] P y â‡’ y â‰ x </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> unique 2 3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">exists_unique</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100} (A âŸ¶ bool) âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆƒ! 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-101</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P] âˆƒ [x] (P x âˆ§ unique P x) </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	 </span><span class="cm">/T Equality on types (semantics missing) â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">tpeq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type âŸ¶ type âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 â‰â‰ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-6</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq </span><span class="p">â™</span><span class="w">	 		</span>
<span class="w">	 </span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	 </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">NaturalDeduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">tru_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">âŠ¦ true </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">fals_elimination</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} âŠ¦ false âŸ¶ âŠ¦ A </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">fals_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} âŠ¦ A âŸ¶ âŠ¦ Â¬ A âŸ¶ âŠ¦ false </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">forall_elim</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100, P : A âŸ¶ bool}âŠ¦ âˆ€ P âŸ¶ {x : A}âŠ¦ P x </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> forallE 3 4</span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">forall_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100, P : A âŸ¶ bool, p : {x : A}âŠ¦P x}âŠ¦ âˆ€[x] P x </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> forallI 3 </span><span class="p">â™</span><span class="w"></span>

<span class="w">	 </span><span class="no">and_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} âŠ¦ A âŸ¶ âŠ¦ B âŸ¶ âŠ¦ (A âˆ§ B) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">and_elim_left</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} âŠ¦ (A âˆ§ B) âŸ¶ âŠ¦ A </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">and_elim_right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} âŠ¦ (A âˆ§ B) âŸ¶ âŠ¦ B </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">not_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} (âŠ¦ A âŸ¶ âŠ¦ false) âŸ¶ âŠ¦ Â¬ A </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">not_elim</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} âŠ¦ Â¬ Â¬ A âŸ¶ âŠ¦ A </span><span class="p">â™</span><span class="w"></span>

<span class="w">	 </span><span class="no">tnd</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} âŠ¦ A âˆ¨ Â¬A </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = [A: bool] not_introduction ([p : âŠ¦ (Â¬A âˆ§ Â¬Â¬A)] fals_introduction (not_elim (and_elim_right p)) (and_elim_left p)) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">/T basic axioms governing Equality. Again, all the type parameters can be left implicit â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">eq_refl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t:ğ’° 100,A: t} âŠ¦ A â‰ A </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> eq_refl 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">eq_cong</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t : ğ’° 100, s : ğ’° 100, f : t âŸ¶ s, A : t, B: t}</span>
<span class="s">	 		âŠ¦ A â‰ B âŸ¶ âŠ¦ (f A) â‰ (f B) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> eq_cong 3 6</span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	 </span>

<span class="cm">/T Now some theories that introduce primitive types and literals for them.</span>
<span class="cm">     Because literals must modify the parser, they are supplied as rules that are implemented in a plugin.âš</span><span class="w">   </span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">NatLiterals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Subtyping </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories?NatLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories?NatRels </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> â„• </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">NAT </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?NatLiterals â™</span><span class="w"></span>
<span class="w">	</span><span class="no">pos_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">âŸ¨ n : nat_lit | âŠ¦ n â‰  0 âŸ© </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> â„•+ </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PosLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">pos_are_nat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit &lt;* nat_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">succ_nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit âŸ¶ pos_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NatSucc </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="cm">// not needed anymore: rule rules?NatSuccInverse â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">plus_pos_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit âŸ¶ pos_lit âŸ¶ pos_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PosPlus </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">plus_nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit âŸ¶ nat_lit âŸ¶ nat_lit </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">plus </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?NatPlus â™</span><span class="w"></span>
<span class="w">   	</span><span class="no">times_pos_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit âŸ¶ pos_lit âŸ¶ pos_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PosTimes </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">times_nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit âŸ¶ nat_lit âŸ¶ nat_lit </span><span class="p">â˜=</span><span class="w"> </span><span class="s">times </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?NatTimes â™</span><span class="w"></span>
<span class="w">    </span><span class="no">leq_nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit âŸ¶ nat_lit âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">LEQ </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?NatLeq â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">IntLiterals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">int_lit</span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> â„¤ </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntegerLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">minus_int_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit âŸ¶ int_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntMinus </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">plus_int_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit âŸ¶ int_lit âŸ¶ int_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntPlus </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">times_int_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit âŸ¶ int_lit âŸ¶ int_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntTimes </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">leq_int_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit âŸ¶ int_lit âŸ¶ bool </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntLeq </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">RealLiterals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	</span><span class="no">real_lit</span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> â„ </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">leq_real_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit âŸ¶ bool </span><span class="p">â™</span><span class="w"></span>
<span class="w">   	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealLeq </span><span class="p">â™</span><span class="w"></span>
<span class="w">   	</span><span class="no">minus_real_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit  </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> - 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">   	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealMinus </span><span class="p">â™</span><span class="w">   </span>
<span class="w">   	</span><span class="no">plus_real_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit âŸ¶ real_lit </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 + 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealPlus </span><span class="p">â™</span><span class="w"></span>
<span class="w">   	</span><span class="no">times_real_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit âŸ¶ real_lit </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 Ã— 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealTimes </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// square_is_pos : {r : â„} âŠ¦ leq_real_lit 0 (times_real_lit r r) â™</span><span class="w"></span>
<span class="w">	</span><span class="no">sqrt</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">â„ âŸ¶ â„ </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealSqrt </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">     </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Literals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?RealLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?IntLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Subtyping </span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">ints_are_real</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit &lt;* real_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">nats_are_int</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit &lt;* int_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">nats_are_real</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit &lt;* real_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">pos_are_int</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit &lt;* int_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">pos_are_real</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit &lt;* real_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// rule rules?NumberLiterals â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">// test : âŠ¦ leq_lit 0 1 â˜ = tru_introduction â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// test2 : âŠ¦ nat_lit_succ 1 â‰ 2 â˜ = eq_refl 2 â™</span><span class="w"></span>
<span class="w">	 </span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Trigonometry</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?RealLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">tan</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit    </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">sin</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit    </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">cos</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit    </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">atan</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit    </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">asin</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit    </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">acos</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit âŸ¶ real_lit    </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Tan </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Sin </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Cos </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Atan </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Asin </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Acos </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	 </span>
<span class="cm">/T String literals are also needed occasionally, e.g., in the LMFDB.âš</span><span class="w"></span>
<span class="w"> </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Strings</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">string</span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?StringLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">concat</span><span class="p">:</span><span class="w"> </span><span class="s">string âŸ¶ string âŸ¶ string</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">/T Now some more complex types. First lists.âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Lists</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Datatypes?LFLists </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">InformalProofs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Strings </span><span class="p">â™</span><span class="w"></span>
<span class="w">   	 </span>
<span class="w">	</span><span class="no">proofsketch</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : prop} string âŸ¶ âŠ¦ A </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> sketch 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">byproof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} âŠ¦ A âŸ¶ âŠ¦ B </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> by 3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">addproofstep</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B,C: prop} âŠ¦ A âŸ¶ âŠ¦ B âŸ¶ âŠ¦ B </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 4 and 5 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">trivial</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : prop} âŠ¦ A </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A] sketch &quot;trivial&quot; </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> trivial %I1 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>


<span class="cm">/T (Finite) sets â™</span>
<span class="cm">theory Sets : ur:?LF =</span>
<span class="cm">   include ?Logicâ™</span>
<span class="cm">   /T the type operator of sets along with its constructorsâ™</span>
<span class="cm">   set: type âŸ¶ type â™</span>
<span class="cm">   </span>
<span class="cm">   empty: {A} (list A) â˜# âˆ… 1â˜## âˆ… %I1 â™</span>
<span class="cm">   cons: {A} A âŸ¶ (list A) âŸ¶ (list A)â˜ # 2 , 3 â™ </span>
<span class="cm">âš</span><span class="w"></span>

<span class="cm">/T Multisets â™</span>

<span class="cm">/T &quot;Finite hybrid sets&quot; (mutlisets with possibly negative mutliplicities) â™</span>

<span class="cm">/T Now vectors, i.e., fixed-length lists.âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Vectors</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Literals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">   </span><span class="cm">/T the type operator of vectors (fixed-length lists) over a given type â™</span><span class="w"></span>
<span class="w">   </span><span class="no">vector</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">ğ’° 100 âŸ¶ nat_lit âŸ¶ type </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ^^ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">zerovec</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t : ğ’° 100} vector t 0 </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">vector_prepend</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t: ğ’° 100,n : nat_lit, a : t, b : vector t n} t ^^ (succ_nat_lit n) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 ; 4</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Matrices</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Vectors </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">  </span><span class="cm">/T the type operator of matrices over a given typeâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">matrix</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">ğ’° 100 âŸ¶ nat_lit âŸ¶ nat_lit âŸ¶ type </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[T,n,m] vector (vector T m) n </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">OptionType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">Option</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">ğ’° 100 âŸ¶ ğ’° 100 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">isDefined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} Option A âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> isDefined 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">OptionGet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A, a : Option A} âŠ¦ isDefined a âŸ¶ A </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">None</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100} Option A </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> None </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">None_is_not_Defined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100} âŠ¦ isDefined (None A) â‰ false </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Not_None_is_Defined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A, a : Option A} âŠ¦ (a â‰  None A) âŸ¶ âŠ¦ isDefined a </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">DescriptionOperator</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?OptionType </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">that</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:ğ’° 100,P:A âŸ¶ bool} âŠ¦ (âˆƒ! P) âŸ¶  A </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Î¹ 2 %I3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">that_proof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100, P : A âŸ¶ bool, p : âŠ¦ âˆƒ! P} âŠ¦ P (that A P p) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">if_then_else_exists_proof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,P,a:A,b:A} âŠ¦ âˆƒ! [x:A] (P âˆ§ x â‰ a) âˆ¨ (Â¬ P âˆ§ x â‰ b) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> iteep 2 3 4</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">if_then_else</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100, P : bool, a : A, b : A}A </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> if 2 then 3 else 4 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">		</span><span class="p">=</span><span class="w"> </span><span class="s">[A,P,a,b] that A ([x] (P âˆ§ x â‰ a) âˆ¨ (Â¬ P âˆ§ x â‰ b)) (iteep P a b) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">if_then_else_case</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100, P : bool, a : A, b : A}A </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P,a,b] if P then a else b </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> case 2 âŸ¹ 3 . 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">if_true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100, P : bool, a : A, b : A, p : âŠ¦ P} âŠ¦ (if P then a else b) â‰ a </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = [A,P,a,b,p] _ </span><span class="p">â˜</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">if_false</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : ğ’° 100, P : bool, a : A, b : A, p : âŠ¦ Â¬ P } âŠ¦ (if P then a else b) â‰ b </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = [A,P,a,b,p] _ </span><span class="p">â˜</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ProductTypes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">http://gl.mathhub.info/MMT/LFX/Sigma?LFSigma</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// to have it in the meta-theory â™</span><span class="w">                       </span>
<span class="p">âš</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">FiniteTypes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">http://gl.mathhub.info/MMT/LFX/Finite?LFFinite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">InductiveTypes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">http://gl.mathhub.info/MMT/LFX/WTypes?Inductive</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Sequences</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?Sequences </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LFS </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">forall_seq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: type}{n} (A^n âŸ¶ prop) âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆ€n 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-101</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">exists_seq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: type}{n} (A^n âŸ¶ prop) âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆƒn 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-101</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,n][P] Â¬ forall_seq A n [s : A^n] Â¬ (P s)</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">/T Finally, a theory that puts everything together (not recommended, because modularity) âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Math</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Subtyping </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?NaturalDeduction </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Literals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Trigonometry </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Strings </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?InformalProofs </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Lists </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Vectors </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Matrices </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?OptionType </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?DescriptionOperator </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?ProductTypes </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sequences </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/sets</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Classes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="no">class</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">cls_element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">class âŸ¶ class âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 âˆˆ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">axiom_extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,t} âŠ¦ (âˆ€[e] e âˆˆ s â‡” e âˆˆ t) â‡’ s â‰ t </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_extensionality 1 2 </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?Subtyping </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?InformalProofs </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">set</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">âŸ¨ s : class | âŠ¦ âˆƒ [C : class] s âˆˆ C âŸ© </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> set </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">emptyclass</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆ… </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_emptyClassIsEmpty</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s} âŠ¦ Â¬ s âˆˆ âˆ… </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_emptyClassIsEmpty 1 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">implicit view</span><span class="w"> </span><span class="nv">ZFinNBG</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?ZFBase</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nv">?Classes</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd?InformalProofs </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd?DescriptionOperator </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">set</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">set </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">element</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] cls_element s t </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">emptyset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">emptyclass </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_emptySetIsEmpty</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s: set] axiom_emptyClassIsEmpty s </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">axiom_extensionality</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] sketch &quot;from extensionality&quot; </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_separation</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[P,s] sketch &quot;axiomatically&quot; </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_regularity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] sketch &quot;axiomatically&quot; </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_pairing</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] sketch &quot;axiomatically&quot; </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_union</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] sketch &quot;axiomatically&quot; </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_powerset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] sketch &quot;axiomatically&quot; </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_replacement</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[a,f] sketch &quot;axiomatically&quot; </span><span class="p">â™</span><span class="w"></span>

<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/sets</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://rules.mitm.mmt.kwarc.info</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SetTypeConversions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">elem</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ type </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">asSet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type âŸ¶ set </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">setAsElem</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,a} âŠ¦ a âˆˆ A âŸ¶ elem A </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> asTerm 1 2 %I3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">elemAsSet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : type} A âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> asElem 2</span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">axiom_asElemIsElem</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,a : A} âŠ¦ (asElem a) âˆˆ (asSet A) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_inverses1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s} âŠ¦ asSet (elem s) â‰ s </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_inverses2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t} âŠ¦ elem (asSet t) â‰ t </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_asTermElem1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,a:A} âŠ¦ asTerm (asSet A) (asElem a) â‰ a </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_asTermElem2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,a,p:âŠ¦a âˆˆ A} âŠ¦ asElem (asTerm A a) â‰ a </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="cm">// rule rules?SetCoercionRule â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LiftSeparation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?SetTypeConversions </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?Subtyping </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">axiom_sepIsPredSub</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,P : set âŸ¶ prop} âŠ¦ elem âŸª s | P âŸ« â‰ âŸ¨ x : (elem s) | âŠ¦ P (asElem x) âŸ© </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_predSubIsSep</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t,P : t âŸ¶ prop} âŠ¦ asSet âŸ¨ x : t | âŠ¦ P x âŸ© â‰ âŸª asSet t | ([x] P (asTerm (asSet t) x)) âŸ« </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LiftProduct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?CartesianProduct </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?KuratowskiPairs </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?SetTypeConversions </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?ProductTypes </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="cm">// axiom_productType : {s,t} âŠ¦ elem (product s t) â‰ (elem s) Ã— (elem t) â˜ role Simplify â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LiftProductType </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_productSet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,t} âŠ¦ asSet (s Ã— t) â‰ product (asSet s) (asSet t) </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_pairType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,t,S,T} âŠ¦ asTerm (product S T) (pair s t) â‰ âŸ¨ (asTerm S s) , (asTerm T t) âŸ© </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_pairSet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{S,T,s : S,t : T} âŠ¦ asElem âŸ¨ s , t âŸ© â‰ pair (asElem s) (asElem t) </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">// theory LiftRelations : fnd:?Logic =</span>
<span class="cm">    include ?Relations â™</span>
<span class="cm">    include ?LiftProduct â™</span>


<span class="cm">    axiom_relType : {a:set,b:set} âŠ¦ elem (â„˜ (product a b)) â‰ (elem a âŸ¶ elem b âŸ¶ prop) â˜ role Simplify â™</span>
<span class="cm">    axiom_relSet : {A,B} âŠ¦ asSet (A âŸ¶ B âŸ¶ prop) â‰ â„˜ (product (asSet A) (asSet B)) â˜ role Simplify â™</span>
<span class="cm">    axiom_relType2 : {a:set,b:set,r: relation a b} âŠ¦ eq (elem a âŸ¶ elem b âŸ¶ prop) (asTerm (â„˜ (product a b)) r) ([x : elem a, y : elem b] (pair (asElem x) (asElem y)) âˆˆ r ) â˜ role Simplify â™</span>
<span class="cm">    axiom_relSet2 : {A,B,R : A âŸ¶ B âŸ¶ prop} âŠ¦ asElem R â‰ âŸª â„˜ (product (asSet A) (asSet B)) | ([x] âˆƒ[a] âˆƒ[b] x â‰ pair a b âˆ§ R (asTerm (asSet A) a) (asTerm (asSet B) b) ) âŸ« â˜ role Simplify â™</span>
<span class="cm">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LiftOmega</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?SetTypeConversions </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Infinity </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?NatLiterals </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">axiom_lift_omega</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">âŠ¦ elem Ï‰ â‰ â„• </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lift_Nat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">âŠ¦ asSet â„• â‰ Ï‰ </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lift_zero</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">âŠ¦ asTerm Ï‰ âˆ… â‰ 0 </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lower_zero</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">âŠ¦ asElem 0 â‰ âˆ… </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lift_succ</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{n} âŠ¦ asTerm Ï‰ (set_succ n) â‰ succ_nat_lit (asTerm Ï‰ n) </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lower_succ</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{n} âŠ¦ asElem (succ_nat_lit n) â‰ set_succ (asElem n) </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/sets</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedSets</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="cm">// include base:?Lists â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?SetTypeConversions </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Powerset </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?Subtyping </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the type operator of sets along with its constructors â™</span><span class="w"></span>
<span class="w">  </span><span class="no">setOf</span><span class="p">:</span><span class="w"> </span><span class="s">type âŸ¶ type </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A] âŸ¨ x : set | âŠ¦ x âˆˆ (â„˜ (asSet A)) âŸ© </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">fromPred</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : type} (A âŸ¶ prop) âŸ¶ setOf A </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P] âŸª â„˜ (asSet A) | ([x] P (asTerm (asSet A) x)) âŸ« </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> asSet 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">asPred</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} setOf A âŸ¶ A âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,s] [x] (asElem x) âˆˆ s </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> asPred 2 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// setCons: {A} A âŸ¶ set A âŸ¶ set A â˜ = [A] [a,P] [x] P x âˆ¨ x â‰ aâ˜ # 3 &lt;- 2 â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// setList : {A} List A âŸ¶  set A â˜ # â‰ª 2 â‰« â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// inSet : {A : type} A âŸ¶ set A âŸ¶ prop â˜ = [A][a,P] P a â˜ # 2 âˆˆ 3 â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// bsetst : {A} set A âŸ¶ (A âŸ¶ prop) âŸ¶ set A â˜ = [A][P,Q] [x] P x âˆ§ Q x â˜ # âŸª 2 | 3 âŸ« â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// fullset : {A} set A â˜ = [A] [x] true â˜ # fullset 1 â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// TODO, need a lot of congruence rules that make sure that setcons ACI â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/sets</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Sets</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">set</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 âˆˆ 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">emptyset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆ… </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">axiom_emptySetIsEmpty</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s} âŠ¦ Â¬ s âˆˆ âˆ… </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">subset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] âˆ€ [z] z âˆˆ s â‡’ z âˆˆ t </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 âŠ‘ 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">disjoint</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] Â¬âˆƒ[e] e âˆˆ s âˆ§ e âˆˆ t </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">prop_extensionality</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t](âˆ€[e] e âˆˆ s â‡” e âˆˆ t) â‡’ s â‰ t </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_separation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">(set âŸ¶ prop) âŸ¶ set âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[P][s]âˆƒ![t]âˆ€[e]e âˆˆ t â‡” (e âˆˆ s âˆ§ P e) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_regularity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s]s â‰  âˆ… â‡’ âˆƒ [e] e âˆˆ s âˆ§ (disjoint s e) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_pairing</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] âˆƒ[z] x âˆˆ z âˆ§ y âˆˆ z </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_pairing_unique</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] âˆƒ![z] x âˆˆ z âˆ§ y âˆˆ z âˆ§ âˆ€[w] w âˆˆ z â‡’ (w â‰ x âˆ¨ w â‰ y) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_union</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x] âˆƒ![y]âˆ€[z] z âˆˆ y â‡” âˆƒ[w] z âˆˆw âˆ§ w âˆˆ x </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_powerset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x]âˆƒ![y] âˆ€[z] z âˆˆ y â‡” z âŠ‘ x </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_replacement</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A][f : set âŸ¶ set] âˆƒ![B]âˆ€[z] (z âˆˆ B â‡” âˆƒ[a] a âˆˆ A âˆ§ z â‰ f a) </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,t} âŠ¦ prop_extensionality s t </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Separation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_separation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{P,s} âŠ¦ prop_separation P s </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_separation 1 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">sep_constructor</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s : set,P : set âŸ¶ prop}set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,P] that set ([x] âˆ€[e]e âˆˆ x â‡” (e âˆˆ s âˆ§ P e)) (axiom_separation P s)</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âŸª 1 | 2 âŸ« </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Intersection</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">intersect</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] âŸª s | ([x] x âˆˆ t) âŸ« </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 âˆ© 2 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Regularity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_regularity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s} âŠ¦ prop_regularity s </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Pairing</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?InformalProofs </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">axiom_pairing</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x,y} âŠ¦ prop_pairing x y </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">lemma_pairing_unique</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x,y : set} âŠ¦ prop_pairing_unique x y </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_pairing_unique 1 2 </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] sketch &quot;provable&quot; </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">uopair</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] that set ([z] x âˆˆ z âˆ§ y âˆˆ z âˆ§ âˆ€[w] w âˆˆ z â‡’ (w â‰ x âˆ¨ w â‰ y)) (lemma_pairing_unique x y) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">singleton</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] uopair s s </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">KuratowskiPairs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Pairing </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">pair</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] uopair (uopair x y) x </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Union</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_union</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x} âŠ¦ prop_union x </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_union 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">union</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] that set ([x] âˆ€[z] z âˆˆ x â‡” âˆƒ[w] z âˆˆw âˆ§ w âˆˆ s) (axiom_union s) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> â‹ƒ 1 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">BinaryUnion</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?KuratowskiPairs </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Union </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">binaryunion</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[a,b] â‹ƒ (uopair a b) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 âˆª 2</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Powerset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_powerset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x} âŠ¦ prop_powerset x </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_powerset 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">powerset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x] that set ([y] âˆ€[z] z âˆˆ y â‡” z âŠ‘ x) (axiom_powerset x) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> â„˜ 1 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">CartesianProduct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Powerset </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?BinaryUnion </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">product</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B] sep_constructor (â„˜ (â„˜ (A âˆª B))) ([p] âˆƒ[a]âˆƒ[b] a âˆˆ A âˆ§ b âˆˆ B âˆ§ p â‰ pair a b) </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Relations</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?CartesianProduct </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?Subtyping </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">prop_relation</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,A,B : set] s âŠ‘ (product A B) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> prop_relation 1 2 3</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">relation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ type </span><span class="p">â˜=</span><span class="w"> </span><span class="s">[A,B] âŸ¨ s : set | âŠ¦ prop_relation s A B âŸ© </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Functions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Relations </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?InformalProofs </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">prop_function</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[f,A,B] prop_relation f A B âˆ§ âˆ€[x] x âˆˆ A â‡’ âˆƒ[y] y âˆˆ B âˆ§ (pair x y) âˆˆ f </span><span class="p">â™</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// TODO â™</span><span class="w"></span>
<span class="w">	</span><span class="no">function</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ type </span><span class="p">â˜=</span><span class="w"> </span><span class="s">[A,B] âŸ¨ s:set | âŠ¦ prop_function s A B âŸ© </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">setfunapply</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} function A B âŸ¶ {a : set}âŠ¦ a âˆˆ A âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f,a,p] Î¹ ([x] (pair a x) âˆˆ f) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 @ 4 %I5 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">theorem_setfun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B,f : function A B, a} âŠ¦ (f @ a) âˆˆ B </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f,a] sketch &quot;by definition&quot; </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Replacement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_replacement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,f} âŠ¦ prop_replacement a f </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_replacement 1 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">replacement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ (set âŸ¶ set) âŸ¶ set </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,f] that set ([B] âˆ€[z] (z âˆˆ B â‡” âˆƒ[a] a âˆˆ A âˆ§ z â‰ f a)) (axiom_replacement A f) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Img 2 of 1 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Infinity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?BinaryUnion </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">set_succ</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[n] n âˆª (singleton n) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_infinity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[N] âˆ… âˆˆ N âˆ§ âˆ€[n] n âˆˆ N â‡’ (set_succ n) âˆˆ N </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">omega</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Ï‰ </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Î¹ [x] prop_infinity x âˆ§ âˆ€[z] prop_infinity z â‡’ x âŠ‘ z</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ZFBase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Extensionality </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Regularity </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Pairing </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Union </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Powerset </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Replacement </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Infinity </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">FunctionsExtended</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Functions </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">prop_injective</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} function A B âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f] âˆ€[x] âˆ€[y] x âˆˆ A âˆ§ y âˆˆ A â‡’ (f@x â‰ f@y â‡’ x â‰ y) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> prop_injective 3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">prop_surjective</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} function A B âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f] âˆ€[y] y âˆˆ B â‡’ âˆƒ[x] x âˆˆ A âˆ§ f@x â‰ y </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> prop_surjective 3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">prop_bijective</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} function A B âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f] prop_injective f âˆ§ prop_surjective f </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> prop_bijective 3 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Finite</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?FunctionsExtended </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Infinity </span><span class="p">â™</span><span class="w"></span>

<span class="w">    </span><span class="no">prop_finite</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] âˆƒ[n] n âˆˆ Ï‰ âˆ§ âˆƒ[f : function s n] prop_injective f </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">prop_infinite</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] Â¬ prop_finite s </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ZF</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?ZFBase </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Finite </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Intersection </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">setdiff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ set </span><span class="p">â˜=</span><span class="w"> </span><span class="s">[A,B] âŸª A | ([x] Â¬ x âˆˆ B) âŸ« </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 \ 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">subtract</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ set </span><span class="p">â˜=</span><span class="w"> </span><span class="s">[A,a] A \ (singleton a) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 - 3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">symdiff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set âŸ¶ set âŸ¶ set </span><span class="p">â˜=</span><span class="w"> </span><span class="s">[A,B] (A \ B) âˆª (B \ A) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 Î” 3 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Choice</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Functions </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_choiceFunction</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,f : function A (â‹ƒ A)] âˆ€[a] a âˆˆ A â‡’ (f @ a) âˆˆ a </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">choice</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} âŸ¨ f : function A (â‹ƒA) | âŠ¦ prop_choiceFunction A f âŸ© </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ZFCBase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?ZFBase </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Choice </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ZFC</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?ZFCBase </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?ZF </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/Units</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://rules.mitm.mmt.kwarc.info</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Dimensions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>

<span class="w">  </span><span class="cm">/T An SI Dimension. â™</span><span class="w"></span>
<span class="w">  </span><span class="no">dimension</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation?IntLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T A normalized representation used for equality reasoning etc. â™</span><span class="w"></span>
<span class="w">  </span><span class="no">NormedDimension</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">â„¤ âŸ¶ â„¤ âŸ¶ â„¤ âŸ¶ â„¤ âŸ¶ â„¤ âŸ¶ â„¤ âŸ¶ â„¤ âŸ¶ dimension </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T We want the actual dimensions as a dimension. â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T We use the SI base dimensions for this. â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Length</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedDimension 1 0 0 0 0 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Time</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedDimension 0 1 0 0 0 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Mass</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 1 0 0 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Amount</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 1 0 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Temperature</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 0 1 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Current</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 0 0 1 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">LuminousIntensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 0 0 0 1 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">DimNone</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 0 0 0 0 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Now we want to make even more dimensions. â™</span><span class="w"></span>
<span class="w">  </span><span class="no">DimTimes</span><span class="p">:</span><span class="w"> </span><span class="s">dimension âŸ¶ dimension âŸ¶ dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *&#39; 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">DimDiv</span><span class="p">:</span><span class="w"> </span><span class="s">dimension âŸ¶ dimension âŸ¶ dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 /&#39; 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?DimEq </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">DimensionsExtended</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Dimensions</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Dimensionless stuffâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">Information</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">DimNone</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Velocity, Accelleration â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Velocity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Length /&#39; Time</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Acceleration</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Velocity /&#39; Time</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Area and Volumeâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">Area</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Length *&#39; Length</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Volume</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Area *&#39; Length</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// Densities â™</span><span class="w"></span>
<span class="w">  </span><span class="no">VolumeDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">DimNone /&#39; Volume </span><span class="p">â˜</span><span class="w">  </span><span class="cm">// # Density //?? </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">AreaDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">DimNone /&#39; Area</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">LineDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">DimNone /&#39; Length</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Force and Pressureâ™</span><span class="w">                   </span>
<span class="w">  </span><span class="no">Force</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Mass *&#39; Acceleration</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Pressure</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Force /&#39; Area</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Electric Charge and Charge Densitiesâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricCharge</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Current *&#39; Time </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricChargeVolumeDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">ElectricCharge *&#39; VolumeDensity </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ElectricChargeDensity</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricChargeAreaDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">ElectricCharge *&#39; AreaDensity </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ElectricChargeSurfaceDensity</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricChargeLineDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">ElectricCharge *&#39; LineDensity</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// Energy and Powerâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">Energy</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Force *&#39; Length </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Power</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Energy /&#39; Time</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// Basic Electrostatic Unitsâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricPotential</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Energy /&#39; ElectricCharge </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Voltage</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricDisplacement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ElectricCharge /&#39; Area </span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">ElectricCurrentDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜=</span><span class="w"> </span><span class="s">Current *&#39; AreaDensity </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Polarization </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// # CurrentDensity </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricField</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Voltage /&#39; Length </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ElectricFieldIntensity </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// Other Electrical Unitsâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalResistance</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Voltage /&#39; Current </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalResistivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ElectricalResistance *&#39; Area /&#39; Length </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalConductivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">DimNone /&#39; ElectricalResistivity </span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">ElectricFlux</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Voltage *&#39; Length </span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">ElectricalCapacitance</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ElectricCharge /&#39; Voltage </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalPermittivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ElectricalCapacitance /&#39; Length </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalMobility</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Velocity /&#39; ElectricField </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">IonRecombination</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Volume /&#39; Time </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Magnetism // Hoping we don&#39;t need that for now</span>
<span class="cm">  </span>
<span class="cm">  // Heat-related , cf. Thermistor exampleâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">Heat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Energy </span><span class="p">â™</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// ThermalConductivity : dimension â˜ = Energy /&#39; Length /&#39; Temperature â™</span><span class="w"> </span><span class="cm">// TODO Name clash with quantities.mmt â™</span><span class="w"></span>
<span class="w">	</span><span class="no">ThermalHeatFlux</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Energy /&#39; Area </span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/Units</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://rules.mitm.mmt.kwarc.info</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="cm">//   http://mathhub.info/MMT/physics-units?QEBase âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Units</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation?RealLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Dimensions </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">unit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension âŸ¶ type </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">QE</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension âŸ¶ type </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">  	</span><span class="cm">/T Dimensionless Quantity Expressions are real numbers â™</span><span class="w"></span>
<span class="w">  	</span><span class="no">NoneIsReal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">âŠ¦ QE DimNone â‰â‰ real_lit </span><span class="p">â™</span><span class="w"></span>
<span class="w">  	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NoneIsReal </span><span class="p">â™</span><span class="w"></span>
<span class="w">  	</span>
<span class="w">	</span><span class="no">unitappl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d : dimension} real_lit âŸ¶ unit d âŸ¶ QE d </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 of 3 </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"># 2 3</span><span class="p">â™</span><span class="w"> </span><span class="cm">// test... â™</span><span class="w"></span>
<span class="w">  	  </span>
<span class="w">  	</span><span class="no">scalar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X} QE X âŸ¶ real_lit </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> scalar 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  	</span><span class="no">scalar_commutes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X : dimension,r, u : unit X} âŠ¦ scalar (r of u) â‰ r </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">  	</span><span class="no">unitof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X} QE X âŸ¶ unit X </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> unitof 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  	</span><span class="no">unitof_commutes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X : dimension,r, u : unit X} âŠ¦ unitof (r of u) â‰ u </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span>
<span class="w">	</span><span class="no">lift</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{din : dimension, dout : dimension, f : â„ âŸ¶ â„, u : unit din âŸ¶ unit dout}QE din âŸ¶ QE dout </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> unit_lift 3 4 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">		</span><span class="p">=</span><span class="w"> </span><span class="s">[din,dout,f,u] [x] (f (scalar x)) of (u (unitof x)) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">UnitTimes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d1, d2} unit d1 âŸ¶ unit d2 âŸ¶ unit (d1 *&#39; d2) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 *&#39;&#39; 4 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">UnitDiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d1, d2} unit d1 âŸ¶ unit d2 âŸ¶ unit (d1 /&#39; d2) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 /&#39;&#39; 4 </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnitEq </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QEBase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T A base Theory for dimensions â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Units </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?DimensionsExtended</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Multiplying with numbers â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// QENMul : {x : dimension} real_lit âŸ¶ QE x âŸ¶ QE x â˜ # 2 . 3 â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Dividing by numbers â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// QENDiv : {x : dimension} QE x âŸ¶ real_lit âŸ¶ QE x â˜ # 2 /. 3 â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Multiplying quantity expressions with each other. â™</span><span class="w"></span>
<span class="w">  </span><span class="no">QEMul</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x : dimension} {y: dimension} QE x âŸ¶ QE y âŸ¶ QE (x *&#39; y) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 â‹… 4 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T Dividing quantity expressions with each other. â™</span><span class="w"></span>
<span class="w">  </span><span class="no">QEDiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x : dimension} {y: dimension} QE x âŸ¶ QE y âŸ¶ QE (x /&#39; y) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 / 4 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Adding quantity expressions (maintains dimension). â™</span><span class="w"></span>
<span class="w">  </span><span class="no">QEAdd</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x : dimension} QE x âŸ¶ QE x âŸ¶ QE x </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 ++ 3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">QESubtract</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x: dimension} QE x âŸ¶ QE x âŸ¶ QE x </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 - 3 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">QEMinus</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x: dimension} QE x âŸ¶ QE x </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ~ 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">QEEExp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">QE DimNone âŸ¶ QE DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> exp 1 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">QEExp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">QE DimNone âŸ¶ QE DimNone âŸ¶ QE DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 â†‘ 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">QEELog</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">QE DimNone âŸ¶ QE DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ln 1 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">QELog</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">QE DimNone âŸ¶ QE DimNone âŸ¶ QE DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> log 1 2 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Field</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?QEBase</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// For now, it&#39;ll be assumed space is of Length dimension by default, </span>
<span class="cm">  but that will have to be specified later for differntiating and integrating</span>
<span class="cm">  over fields defined on space of an arbitrary variable dimensionâ™</span><span class="w"></span>

<span class="w">  </span><span class="no">space</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">spaceDim</span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Length </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">field</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension âŸ¶ type </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[d]	space âŸ¶ QE d </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">FieldAdd</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d: dimension} field d  âŸ¶ field d  âŸ¶ field d </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 .+ 3 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d,f1,f2] [s] (f1 s) ++ (f2 s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">FieldSubtract</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d: dimension} field d âŸ¶ field d  âŸ¶ field d </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 .- 3 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d,f1,f2] [s] (f1 s) - (f2 s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">FieldMul</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d1: dimension, d2: dimension} field d1 âŸ¶ field d2  âŸ¶ field (d1 *&#39; d2) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 .* 4 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d1,d2,f1,f2] [s] (f1 s) â‹… (f2 s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">FieldDiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d1: dimension, d2: dimension} field d1 âŸ¶ field d2  âŸ¶ field (d1 /&#39; d2) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 ./ 4 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d1,d2,f1,f2] [s] (f1 s) / (f2 s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">FieldMinus</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d: dimension} field d  âŸ¶ field d </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> .~ 2 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d,f] [s] ~ (f s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	         </span>
<span class="w">	</span><span class="no">FieldEExp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">field DimNone âŸ¶ field DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> exp. 1 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">					 </span><span class="p">=</span><span class="w"> </span><span class="s">[f] [s] exp (f s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">					 </span>
<span class="w">	</span><span class="no">FieldExp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">field DimNone âŸ¶ field DimNone âŸ¶ field DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 .â†‘ 2 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">					 </span><span class="p">=</span><span class="w"> </span><span class="s">[f1,f2] [s] (f1 s) â†‘ (f2 s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">					 </span>
<span class="w">	</span><span class="no">FieldLog</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">field DimNone âŸ¶ field DimNone âŸ¶ field DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> log. 1 2 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">					 </span><span class="p">=</span><span class="w"> </span><span class="s">[f1,f2] [s] log (f1 s) (f2 s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">					 </span>
<span class="w">	</span><span class="no">FieldELog</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">field DimNone âŸ¶ field DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ln. 1 </span><span class="p">â˜</span><span class="w"></span>
<span class="w">					 </span><span class="p">=</span><span class="w"> </span><span class="s">[f] [s] ln (f s) </span><span class="p">â™</span><span class="w"></span>

<span class="w">	</span><span class="no">FieldEq</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{d: dimension} field d âŸ¶ field d  âŸ¶ prop </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 .â‰ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">â˜</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d,f1,f2] âˆ€ [s] (f1 s) â‰ (f2 s) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	         </span>
<span class="w">	</span><span class="no">FieldInteg</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d} field d âŸ¶ field (d *&#39; spaceDim) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆ‘. 2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">FieldDeriv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d} field d âŸ¶ field (d /&#39; spaceDim) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Î”. 2 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/Units</span><span class="w"> </span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SIUnits</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?QEBase</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">// include ?InformationBaseâ™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">NormedUnit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b,c,d,e,f,g}unit (NormedDimension a b c d e f g) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> NormedUnit 1 2 3 4 5 6 7 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">Meter</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Length </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedUnit 1 0 0 0 0 0 0 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Second</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Time</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedUnit 0 1 0 0 0 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Kilogram</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Mass</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> kg </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 1 0 0 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Mole</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Amount </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 1 0 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Kelvin</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Temperature</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 0 1 0 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Ampere</span><span class="p">:</span><span class="w"> </span><span class="s">unit Current</span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 0 0 1 0</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Candela</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit LuminousIntensity </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 0 0 0 1 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Scalar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit DimNone </span><span class="p">â˜</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 0 0 0 0 </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">UnitsExtended</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?DimensionsExtended</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?SIUnits </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">bit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Information </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Scalar </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">m2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Area </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Meter *&#39;&#39; Meter </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> mÂ² </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">m3</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Volume </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">mÂ² *&#39;&#39; Meter </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> mÂ³ </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">mps</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Velocity </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Meter /&#39;&#39; Second </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">mpss</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Acceleration </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Meter /&#39;&#39; (Second *&#39;&#39; Second) </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">newton</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Force </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">kg *&#39;&#39; mpss </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> N </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">pascal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Pressure </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">N /&#39;&#39; mÂ² </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Pa </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">joule</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Energy </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">N *&#39;&#39; Meter </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://cf.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">CF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?PLF</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="kd">constant</span><span class="w"> </span><span class="no">instance</span><span class="w"> </span><span class="p">#</span><span class="s"> instance 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">new</span><span class="w">    </span><span class="p">#</span><span class="s"> new 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NewInstance</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">field</span><span class="w">    </span><span class="p">#</span><span class="s"> 1 . 2</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span>
<span class="w">   </span><span class="no">sequence</span><span class="w"> </span><span class="p">#</span><span class="s"> var V1;â€¦ in 2;â€¦</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Sequence</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">None</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">none</span><span class="p">:</span><span class="w"> </span><span class="s">None</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">   </span><span class="no">assign</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 = 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Assignment</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?AssignmentTerm</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">meta</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Dedukti</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?PLF</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">rewriteType</span><span class="p">:</span><span class="w"> </span><span class="s">type âŸ¶ type âŸ¶ type</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ---&gt; 2</span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">rewriteTerm</span><span class="p">:</span><span class="w"> </span><span class="s">{a: type} a âŸ¶ a âŸ¶ type </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 --&gt; 2</span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w">                                   </span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://quotation.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="cm">/T   higher-order logic with quotation and evaluation, mostly following Bill Farmer&#39;s work âš</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">HOLQE</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="sd"># Higher-order logic</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">   </span><span class="sd">## Types</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T the LF-type representing HOL types â™</span><span class="w"> </span>
<span class="w">   </span><span class="no">tp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T function types â™</span><span class="w"> </span>
<span class="w">   </span><span class="no">fun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tp âŸ¶ tp âŸ¶ tp</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 â‡’ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Normally we represent object language variables using LF variables, in which case the following is redundant.</span>
<span class="cm">      But Farmer&#39;s language follows the traditional style of assuming an infinite supply of variables at every type.</span>
<span class="cm">      It is critical to capture this in the representation because he allows quoting terms with free variables.â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the type of variables at a given HOL typeâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">Var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tp âŸ¶ type</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the constructor for concrete variables %x:a at a given HOL type where x is any identifier that is parsed as a closed term</span>
<span class="cm">      Most of the time, we do not need this because we can use LF-variables v:Var a as meta-variables that range over HOL variables at type a.â™</span><span class="w"> </span>
<span class="w">   </span><span class="no">var</span><span class="w"> </span><span class="p">#</span><span class="s"> % L1T </span><span class="k">prec</span><span class="w"> </span><span class="mi">200</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the typing rule (%x:a):Var a for concrete variables cannot be expressed in LF, so we implement an MMT ruleâ™</span><span class="w"> </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ConcreteVariable</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd">## Terms</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the LF-type representing HOL terms of a given HOL type â™</span><span class="w">  </span>
<span class="w">   </span><span class="no">tm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tp âŸ¶ type</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> tm 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T all variables are terms of their respective type â™</span><span class="w"> </span>
<span class="w">   </span><span class="no">tvar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} Var a âŸ¶ tm a</span><span class="p">â˜#</span><span class="s"> tvar 2</span><span class="p">â˜#</span><span class="s"># 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T Î»-abstraction (contrary to typical LF-encodings, we bind explicit variables that have to be injected into terms using tvar â™</span><span class="w"> </span>
<span class="w">   </span><span class="no">lam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a, b} (Var a âŸ¶ tm b) âŸ¶ tm a â‡’ b</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Î» 3</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T application â™</span><span class="w"> </span>
<span class="w">   </span><span class="no">app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a, b} tm a â‡’ b âŸ¶ tm a âŸ¶ tm b</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 @ 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T undefined terms (not needed here, but probably needed later on when evaluating quotations of ill-typed termsâ™</span><span class="w"> </span>
<span class="w">   </span><span class="no">undefined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm a</span><span class="p">â˜#</span><span class="s"> âŠ¥ 1</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T booleans, connectives, and proofsâ™</span><span class="w"> </span>
<span class="w">   </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tp</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">equal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm a âŸ¶ tm a âŸ¶ tm bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 = 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">ded</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">tm bool âŸ¶ type</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âŠ¦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd"># Quotation</span><span class="p">â™</span><span class="w"> </span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T We add HOL types that reify HOL conceptsâ™</span><span class="w"> </span>

<span class="w">   </span><span class="sd">## Quoting Terms</span><span class="p">â™</span><span class="w"> </span>

<span class="w">   </span><span class="cm">/T We add a type holding quotations of HOL terms. All terms may be quoted, including ill-typed ones.</span>
<span class="cm">      Effectively, this amounts to having a type that represents the untype Î»-calculus inside a typed Î»-calculus.â™</span><span class="w"> </span>

<span class="w">   </span><span class="sd">### Syntax</span><span class="p">â™</span><span class="w">    </span>
<span class="w">      </span>
<span class="w">   </span><span class="cm">/T the type of quoted termsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">qtp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">tp </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Îµ</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted variablesâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">qvar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} Var a âŸ¶ tm Îµ</span><span class="p">â˜#</span><span class="s"> qvar 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="p">â˜#</span><span class="s"># qvar 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted Î»-abstractionsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">qlam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} Var a âŸ¶ tm Îµ âŸ¶ tm Îµ </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> qlam 2 . 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">150</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted applicationsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">qapp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tm Îµ âŸ¶ tm Îµ âŸ¶ tm Îµ </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> qapp 1 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted quotationsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">qquote</span><span class="p">:</span><span class="w"> </span><span class="s">tm Îµ âŸ¶ tm Îµ</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Finally, we add a meta-level operation that turns a term into the corresponding quotation.</span>
<span class="cm">      We may think of it as having type ${a}tm a âŸ¶ tm Îµ$ except. However, quotation may not be subject to congruence and therefore cannot have an LF type.â™</span><span class="w">   </span>
<span class="w">   </span><span class="no">quote</span><span class="w"> </span><span class="p">#</span><span class="s"> âŒœ 1 âŒ  </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the rule that eliminates occurrences of quote by constructing the corresponding term of type $tm Îµ$</span>
<span class="cm">      HOL variables in the argument are quoted using $qvar$, LF variables remain, which gives rise to quasi-quotation.â™</span><span class="w"> </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteTerm</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="sd">### Semantics</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T the predicate expressing that a term is the quotation of a term of a given types.â™</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">tm Îµ âŸ¶ tp âŸ¶ tm bool</span><span class="p">â˜#</span><span class="s"> 1 $ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted variablesâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype_var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,v: Var a} âŠ¦ qvar v $ a</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted Î»-abstractionsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype_lam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b,v:Var a,E} âŠ¦ E $ b âŸ¶ âŠ¦ qlam v.E $ a â‡’ b</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted applicationsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype_app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b,F,E} âŠ¦ F $ a â‡’ b âŸ¶ âŠ¦ E $ a âŸ¶ âŠ¦ qapp F E $ a â‡’ b</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted quotationsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype_quote</span><span class="p">:</span><span class="w"> </span><span class="s">{E,a} âŠ¦ E $ a âŸ¶ âŠ¦ qquote E $ Îµ</span><span class="p">â™</span><span class="w">   </span>

<span class="w">   </span><span class="sd">## Quoting Substitutions</span><span class="p">â™</span><span class="w"> </span>

<span class="w">   </span><span class="cm">/T Expanding on Farmer&#39;s work, we also add a type holding HOL substitutions.</span>
<span class="cm">      Effectively, this amounts to a language with explicit substitutions.</span>
<span class="cm">      Because all variables are always in scope, every substitution maps all variables to terms.â™</span><span class="w"> </span>

<span class="w">   </span><span class="sd">### Syntax</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the type of substitutionsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">stp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">tp</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> sub</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the identity substitutionsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">idsub</span><span class="p">:</span><span class="w"> </span><span class="s">tm sub</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the substitution that modifies a given substitution in one placeâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">update</span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm sub âŸ¶ Var a âŸ¶ tm a âŸ¶ tm sub </span><span class="p">â˜#</span><span class="s"> 2 + 3 â†¦ 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">50</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T abbreviation for the substitution that maps one variableâ™</span><span class="w">   </span>
<span class="w">   </span><span class="no">singlesub</span><span class="p">:</span><span class="w"> </span><span class="s">{a} Var a âŸ¶ tm a âŸ¶ tm sub </span><span class="p">â˜#</span><span class="s"> 2 â†¦ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">51</span><span class="p">â˜</span><span class="w"></span>
<span class="w">            </span><span class="p">=</span><span class="w"> </span><span class="s">[a,v,t] idsub + v â†¦ t</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Finally, we add a meta-level operation that turns a substitution into the corresponding quotation.â™</span><span class="w">   </span>
<span class="w">   </span><span class="no">subs</span><span class="w"> </span><span class="p">#</span><span class="s"> ` L1T,â€¦ Â´  </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the rule that eliminates occurrences of subs by constructing the corresponding term of type $tm sub$â™</span><span class="w"> </span>
<span class="w">   </span><span class="cm">// rule rules?QuoteSubsâ™</span><span class="w"></span>

<span class="w">   </span><span class="sd">### Semantics</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T an auxiliary predicate to reason about inequality of variablesâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">diff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b} Var a âŸ¶ Var b âŸ¶ tm bool </span><span class="p">â˜#</span><span class="s"> 3 â‰  4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class="p">â™</span><span class="w"> </span><span class="cm">// notation parsing errors not reported correctly? â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the function that retrieves the map of a variable by a substitutionâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">lookup</span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm sub âŸ¶ Var a âŸ¶ tm a </span><span class="p">â˜#</span><span class="s"> 3 &#39; 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">15</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for the identity substitutionâ™</span><span class="w">   </span>
<span class="w">   </span><span class="no">subst_id</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">{a,v: Var a} âŠ¦ v&#39;idsub = (tvar v)</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for an update to the needed variablesâ™</span><span class="w">   </span>
<span class="w">   </span><span class="no">subst_update_same</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,a, v: Var a, E} âŠ¦ v&#39;(s+vâ†¦E) = E</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for an update to some other variableâ™</span><span class="w">   </span>
<span class="w">   </span><span class="no">subst_update_diff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,a,b, v: Var a, w: Var b, E} âŠ¦ v â‰  w âŸ¶ âŠ¦ v&#39;(s+wâ†¦E) = v&#39;s</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd"># Evaluation</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T Evaluation internalizes the model-theoretical semantics: evaluation takes a term and a substitution (which provides the assignment to the free variables) and returns its interpretation in the model.</span>
<span class="cm">   </span>
<span class="cm">   Evaluation is only defined for quotations of well-typed terms. Because the type of a quotation is not stored in the quotation,</span>
<span class="cm">   * evaluation takes a HOL-type as an additional argument,</span>
<span class="cm">   * evaluation rules take typing assumptions.â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the evaluation operatorâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">eval</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm Îµ âŸ¶ tm sub âŸ¶ tm a </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âŸ¦ 2 $ 1 âŸ§ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"># âŸ¦ 2 $ 1 âŸ§ ^ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for variables: apply the assignmentâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">eval_var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a, v: Var a, s} âŠ¦ (âŸ¦qvar v $ aâŸ§s) = v&#39;s</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for Î»-abstractions qlam v.E: build the function that maps x to the evaluation of E under the assignment of v to xâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">eval_fun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a, b, v: Var a, E, s} âŠ¦ E $ b âŸ¶ âŠ¦ (âŸ¦qlam v.E $ a â‡’ bâŸ§s) = Î»[x](âŸ¦E $ bâŸ§ s + v â†¦ tvar x)</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for applications: straightforwardâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">eval_app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b, F, X, s} âŠ¦ F $ a â‡’ b  âŸ¶  âŠ¦ X $ a  âŸ¶  âŠ¦ (âŸ¦qapp F X $ bâŸ§s) = (âŸ¦F $ a â‡’ bâŸ§s) @ âŸ¦X $ aâŸ§s</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for quotations: evaluation cancels quotationâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">eval_quote</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X, s} âŠ¦ X $ Îµ  âŸ¶  âŠ¦ (âŸ¦qquote X $ ÎµâŸ§s) = X</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">  </span>
<span class="cm">/T Now we formalize two challenge problems posed by Farmerâš</span><span class="w"></span>
<span class="w"> </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">ExcludedMiddle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?HOLQE</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">not</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tm bool âŸ¶ tm bool</span><span class="p">â˜#</span><span class="s"> Â¬ 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">or</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">tm bool âŸ¶ tm bool âŸ¶ tm bool</span><span class="p">â˜#</span><span class="s"> 1 âˆ¨ 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">em</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{f,s} âŠ¦ f $ bool âŸ¶ âŠ¦ (âŸ¦f$boolâŸ§s) âˆ¨ Â¬ âŸ¦f$boolâŸ§s </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">PolyDiff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?HOLQE</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T real numbers and derivativesâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">R</span><span class="p">:</span><span class="w"> </span><span class="s">tp</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">derivative</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tm R â‡’ R âŸ¶ tm R â‡’ R</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T a transformer that computes the derivative of a polynomial and its meaning formulaâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">ispolyin</span><span class="p">:</span><span class="w"> </span><span class="s">tm Îµ âŸ¶ Var R âŸ¶ tm bool</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">polyderiv</span><span class="p">:</span><span class="w"> </span><span class="s">tm Îµ âŸ¶ Var R âŸ¶ tm Îµ</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">meaning</span><span class="p">:</span><span class="w"> </span><span class="s">{v, p} âŠ¦ ispolyin p v âŸ¶ âŠ¦ derivative (Î»[x] âŸ¦p $ RâŸ§v â†¦ tvar x) = (Î»[x] âŸ¦polyderiv p v $ RâŸ§v â†¦ tvar x) </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://intersection.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="cm">/T   A representation of intersection types in MMT, following &quot;Towards a Logical Framework with Intersection and Union Types&quot; by Stolze, Liquori, Honsell, Scagnetto.âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Intersection</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T intersection typeâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">inter</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 âˆ© 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T elements of an intersection typeâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">pair</span><span class="w"> </span><span class="p">#</span><span class="s"> âŸ¨ 1 , 2 âŸ© </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T projections from an intersection typeâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">project1</span><span class="w"> </span><span class="p">#</span><span class="s"> proj1 1 </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">project2</span><span class="w"> </span><span class="p">#</span><span class="s"> proj2 1 </span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InterTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PairTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Projection1Term</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Projection2Term</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InterTyping</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InterEqual</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">IntersectionTest</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?Intersection</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">  </span><span class="no">a</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">b</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T auto-application â™</span><span class="w"></span>
<span class="w">  </span><span class="no">test</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">((a âŸ¶ b) âˆ© a) âŸ¶ b</span><span class="p">â˜</span><span class="w"></span>
<span class="w">       </span><span class="p">=</span><span class="w"> </span><span class="s">[x] (proj1 x) (proj2 x)</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T This is a negative test: it should fail with an error that $(a âŸ¶ b)âˆ©(a âŸ¶ b)$ is not equal to $(a âŸ¶ b)âˆ©a$.â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// test2 = test testâ™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Isabelle</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt?Errorsâš</span>
<span class="s">   include ?PLF</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">prop</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">ded</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">prop âŸ¶ type </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âŠ¦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">0</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">proof</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">meta</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt</span><span class="p">âš</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Typed</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype</span><span class="w">   </span><span class="p">#</span><span class="s"> : 1 </span><span class="k">prec</span><span class="w">  </span><span class="mi">-9995</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">equality</span><span class="w"> </span><span class="p">#</span><span class="s"> equality 1 2  </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">typeAttribution</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 : 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9997</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">OMLType</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">defAttribution</span><span class="w">  </span><span class="p">#</span><span class="s"> 1 := 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9998</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">OMLDef </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">notationAttribution</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 # 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9998</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">OMLNotation </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Kinded</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Typed</span><span class="p">â™</span><span class="w"></span>
<span class="w">	 </span><span class="no">kind</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedConstants</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UniverseType</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TypeInhabitable </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">KindedConstants</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UniverseKind</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?KindInhabitable </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">TermsTypesKinds</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">meta:?Errors</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?ModExp</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">meta:?mmt</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Typed </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Kinded </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedConstants </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?KindedConstants </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnivTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TypeAttributionTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?DropTypeAttribution</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LambdaPi</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Kinded</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">Pi</span><span class="w">     </span><span class="p">#</span><span class="s"> { V1T,â€¦ } 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">lambda</span><span class="w"> </span><span class="p">#</span><span class="s"> [ V1T,â€¦ ] 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">apply</span><span class="w">  </span><span class="p">#</span><span class="s"> 1%wâ€¦        </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">arrow</span><span class="w">  </span><span class="p">#</span><span class="s"> 1âŸ¶â€¦         </span><span class="k">prec</span><span class="w">  </span><span class="mi">-9990</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LambdaPi</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiType</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ApplyTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LambdaTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Beta</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Extensionality</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiCongruence</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LambdaCongruence</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NormalizeCurrying</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Solve</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SolveType</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TheoryTypeWithLF</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiIntroduction</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ForwardPiElimination</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?BackwardPiElimination</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiIrrelevanceRule</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LFHOAS</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?TermsTypesKinds</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LambdaPi </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LFRules </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">ShallowPolymorphism</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Typed</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ShallowPolymorphism</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PolymorphicApplyTerm </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?ShallowPolymorphism</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFModulo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">equality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type} A âŸ¶ A âŸ¶ type </span><span class="p">â˜#</span><span class="s"> 2 = 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9000</span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w">                                                                              </span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="cm">/T LLF_P as introduced by Honsell, Liquori, Maksimovi, Scagnetto in</span>
<span class="cm">A logical framework for modeling external evidence, side conditions, and proof irrelevance using monadsâš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://externals.lf.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Locks</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="cm">// Lp p a b &lt;T&gt; is the type \mathcal{L}^p_{a,b}[T] from the paper.â™</span><span class="w"></span>
<span class="w">   </span><span class="no">locktype</span><span class="w"> </span><span class="p">#</span><span class="s"> Lp 1 2 3 &lt; 4 &gt; </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// Lm p a b &lt;t&gt; is the term \mathcal{L}^p_{a,b}[t] from the paper.â™</span><span class="w"></span>
<span class="w">   </span><span class="no">lockterm</span><span class="w"> </span><span class="p">#</span><span class="s"> Lm 1 2 3 &lt; 4 &gt; </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// U &lt;t&gt; for t:Lp p a b &lt;T&gt; is the term \mathcal{U}^p_{a,b}[t] from the paper.</span>
<span class="cm">      U is unary here because p, a, and b can be inferred from t.â™</span><span class="w"></span>
<span class="w">   </span><span class="no">unlock</span><span class="w"> </span><span class="p">#</span><span class="s"> U &lt; 1 &gt; </span><span class="p">â™</span><span class="w">                                           </span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// Convenience operator to bundle p, a, b into a single object.</span>
<span class="cm">   key # K 1 2 3â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">// The typing rules.â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InferLockType</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InferLockTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InferUnlock</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TypingLock</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EqualityLock</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnlockLock</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LLFP</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Locks</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">CallByValueExample</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LLFP</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T following Section 5.1 of the paper: call-by-value reduction â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T untyped Î» calculus â™</span><span class="w"></span>
<span class="w">   </span><span class="no">term</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">term âŸ¶ term âŸ¶ term </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 @ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">50</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">lam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">(term âŸ¶ term) âŸ¶ term</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> Î» 1</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T natural numbers â™</span><span class="w"></span>
<span class="w">   </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">z</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">S</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat âŸ¶ nat</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T free variables using natural numbersâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">free</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat âŸ¶ term</span><span class="p">â˜#</span><span class="s"> &#39; 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T equality judgment and its rules â™</span><span class="w"></span>
<span class="w">   </span><span class="no">eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">term âŸ¶ term âŸ¶ type</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 â‰ 2 </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Judgment</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">refl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M} M â‰ M</span><span class="p">â˜#</span><span class="s"> refl 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">symm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M,N} M â‰ N âŸ¶ N â‰ M</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">trans</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M,N,P} M â‰ N âŸ¶ N â‰ P âŸ¶ M â‰ P</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">eq_app</span><span class="p">:</span><span class="w"> </span><span class="s">{M,N,X,Y} M â‰ N âŸ¶ X â‰ Y âŸ¶ M@X â‰ N@Y</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> eq_app 5 6</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T We declare a single constant Val for the side condition and one rule that implements it.</span>
<span class="cm">      The condition Val N term checks if N:term is an abstraction or a free variable â™</span><span class="w"></span>
<span class="w">   </span><span class="no">Val</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ValRule</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T reduction rules using Val conditionâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">betav</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M,N} Lp Val N term &lt;(Î» M)@N â‰ (M N)&gt;</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> betav 1 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">csiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M,N}({x} Lp Val x term &lt;(M x) â‰ (N x)&gt;) âŸ¶ (Î» M) â‰ (Î» N)</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> csiv 3</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T example from the end of the section â™</span><span class="w"></span>
<span class="w">   </span><span class="no">t1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Î»[x] &#39;z @ ((Î»[y] y) @ x)</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">t2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Î»[x] &#39;z @ x</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">goal</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">t1 â‰ t2</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T The following check succeeds without ever calling the ValRule because the unlock is under a lock.â™</span><span class="w"></span>
<span class="w">   </span><span class="no">check</span><span class="p">:</span><span class="w"> </span><span class="s">goal </span><span class="p">â˜</span><span class="w"></span>
<span class="w">     </span><span class="p">=</span><span class="w"> </span><span class="s">csiv [x] Lm Val x term &lt;</span>
<span class="s">       eq_app (refl &#39;z) U&lt;betav ([y] y) x&gt;</span>
<span class="s">     &gt;</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T The following example does not guard the unlock but still succeeds because &#39;n is indeed a value.â™</span><span class="w"></span>
<span class="w">   </span><span class="no">check2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[n] eq_app (refl &#39;z) U&lt;betav ([y] y) &#39;n&gt;</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T The following negative example fails because x is any term and thus not necessarily a value.â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// fail   = [x] eq_app (refl &#39;z) U&lt;betav ([y] y) x&gt;â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://api.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Errors</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="cm">// a missing term of a given type â™</span><span class="w"> </span>
<span class="w">   </span><span class="no">missing</span><span class="w">   </span><span class="p">#</span><span class="s"> â‰ª 1 â‰«        </span><span class="k">prec</span><span class="w"> </span><span class="mi">-99500</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// a term not matching a required type â™</span><span class="w"></span>
<span class="w">   </span><span class="no">illtyped</span><span class="w">  </span><span class="p">#</span><span class="s"> â‰ª 1 :: 2 â‰«   </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100000</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// an unknown term (e.g., an omitted proof) that uses certain subterms (e.g., the used axioms) â™</span><span class="w"></span>
<span class="w">   </span><span class="no">unknown</span><span class="w">   </span><span class="p">#</span><span class="s"> â‰ª using 1,â€¦ â‰« </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100003</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">// this notation clashes with unbracketed lambdas inside some other unknown, removed for now</span>
<span class="cm">   // unsolved  # â‰ª [ V1T,â€¦ ] 2 â‰« prec -100006â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// an ambiguous term with multiple options; its first argument is the number of the argument that was obtained as the result of disambiguation (starting from 0) â™</span><span class="w"></span>
<span class="w">   </span><span class="no">oneOf</span><span class="w">     </span><span class="p">#</span><span class="s"> â‰ª 1 @ 2,â€¦ â‰« </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100002</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// infers the type of missing termsâ™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/checking?HoleTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// reduces disambiguated term â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/checking?Disambiguation</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// disambiguates terms formed by oneOf â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/checking?InferAmbiguous</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">mmt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">   </span><span class="cm">// binds unsolved meta-variables â™</span><span class="w"></span>
<span class="w">   </span><span class="no">unknown</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// binds free variables that are implicitly quantified at the toplevelâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">free</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// the type of all rulesâ™</span><span class="w"></span>
<span class="w">   </span><span class="kd">constant</span><span class="w"> </span><span class="no">rule</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/parser?GenericEscapeLexer</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// rule info.kwarc.mmt.api.parser?UnicodeReplacerâ™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/parser?MMTURILexer</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// the type of notationsâ™</span><span class="w"></span>
<span class="w">   </span><span class="no">notation</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// enables notation literalsâ™</span><span class="w"> </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/notations?NotationRealizedType</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/patterns?PatternFeature</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/patterns?InstanceFeature</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">// notations with round brackets must have a lower precedence than this to be recognized â™</span><span class="w"></span>
<span class="w">   </span><span class="no">brackets</span><span class="w">     </span><span class="p">#</span><span class="s"> ( 1 ) </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000005</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// left bracket with omitted partner as far to the right as consistent with round brackets â™</span><span class="w"></span>
<span class="w">   </span><span class="no">andrewsDot</span><span class="w">   </span><span class="p">#</span><span class="s"> â–ª 1  </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000000</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="cm">// right bracket with omitted partner as far to the left as consistent with round brackets â™</span><span class="w"></span>
<span class="w">   </span><span class="no">andrewsDotRight</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 â–«  </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000000</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">PL</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype</span><span class="w">   </span><span class="p">#</span><span class="s"> : 1</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">List</span><span class="w">     </span><span class="p">#</span><span class="s"> List 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">list</span><span class="w">     </span><span class="p">#</span><span class="s"> [ 1,â€¦ ]</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Option</span><span class="w">   </span><span class="p">#</span><span class="s"> Option 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">some</span><span class="w">     </span><span class="p">#</span><span class="s"> some 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">none</span><span class="w">     </span><span class="p">#</span><span class="s"> none</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Tuple</span><span class="w">    </span><span class="p">#</span><span class="s"> 1Ã—â€¦</span><span class="p">â™</span><span class="w"> </span>
<span class="w">   </span><span class="no">tuple</span><span class="w">    </span><span class="p">#</span><span class="s"> âŸ¨ 1,â€¦ âŸ© </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">proj</span><span class="w">     </span><span class="p">#</span><span class="s"> 1 . 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Function</span><span class="w"> </span><span class="p">#</span><span class="s"> 1Ã—â€¦ âŸ¶ 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">lambda</span><span class="w">   </span><span class="p">#</span><span class="s"> Î» V1T,â€¦ . -2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">apply</span><span class="w">    </span><span class="p">#</span><span class="s"> 1@â€¦</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Nat</span><span class="w">   </span><span class="p">#</span><span class="s"> â„•</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">plus</span><span class="w">  </span><span class="p">#</span><span class="s"> 1+â€¦</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">times</span><span class="w"> </span><span class="p">#</span><span class="s"> 1*â€¦</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">minus</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 - 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">div</span><span class="w">   </span><span class="p">#</span><span class="s"> 1 / 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">less</span><span class="w">      </span><span class="p">#</span><span class="s"> 1 &lt; 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">lesseq</span><span class="w">    </span><span class="p">#</span><span class="s"> 1 â‰¤ 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">greater</span><span class="w">   </span><span class="p">#</span><span class="s"> 1 &gt; 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">greatereq</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 â‰¥ 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Boolean</span><span class="w"> </span><span class="p">#</span><span class="s"> â„¬</span>
<span class="s">   and     # 1âˆ§â€¦</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">or</span><span class="w">      </span><span class="p">#</span><span class="s"> 1âˆ¨â€¦</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">equal</span><span class="w">   </span><span class="p">#</span><span class="s"> 1 = 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">ifte</span><span class="w">    </span><span class="p">#</span><span class="s"> if ( 1 ) 2 else 3</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">match</span><span class="w">   </span><span class="p">#</span><span class="s"> 1 match 2|â€¦ </span><span class="k">prec</span><span class="w"> </span><span class="mi">50</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">case</span><span class="w">    </span><span class="p">#</span><span class="s"> [ V2T,â€¦ ] 1 â‡ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://moduleexpressions.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ModExp</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kd">constant</span><span class="w"> </span><span class="no">theory</span><span class="w">   </span><span class="p">#</span><span class="s"> THY</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kd">constant</span><span class="w"> </span><span class="no">morphism</span><span class="w"> </span><span class="p">#</span><span class="s"> MOR 1 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">complextheory</span><span class="w">   </span><span class="p">#</span><span class="s"> {| L1Td,â€¦ |} </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000005</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">complexmorphism</span><span class="w"> </span><span class="p">#</span><span class="s"> [| L1D,â€¦ |] </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000005</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">identity</span><span class="w">        </span><span class="p">#</span><span class="s"> IDENTITY 1   </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">composition</span><span class="w">     </span><span class="p">#</span><span class="s"> COMPOSE 1;â€¦ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="cm">// morphismapplication # %L2d!_1 APPLY 2â™</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TheoryTypeInhabitable</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TheoryTypeUniverse</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MorphTypeInhabitable</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComplexTheoryInfer</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?AnonymousTheoryInfer</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MorphCheck</span><span class="p">â™</span><span class="w">     </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MorphismApplicationTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MorphismApplicationCompute</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Combinators</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?ModExp</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">empty</span><span class="w"> </span><span class="p">#</span><span class="s"> EMPTY 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">extends</span><span class="w">  </span><span class="p">#</span><span class="s"> 1 EXTEND { %L1_L2,â€¦ } </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">rename1</span><span class="w"> </span><span class="p">#</span><span class="s"> L1 âŸ¿ L2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-500000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">rename</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 RENAME { 2,â€¦ } </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">combine</span><span class="w">  </span><span class="p">#</span><span class="s"> COMBINE 1 { 2,â€¦ } 3 { 4,â€¦ } </span><span class="k">prec</span><span class="w"> </span><span class="mi">-2000000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">translate</span><span class="w"> </span><span class="p">#</span><span class="s"> MIXIN 1 { 2,â€¦ } 3 { 4,â€¦ } </span><span class="k">prec</span><span class="w"> </span><span class="mi">-2000000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComputeEmpty </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComputeExtends </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComputeRename </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComputeCombine </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?ComputeMixin â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFComb</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Combinators</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://www.openmath.org/cd</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">OpenMath</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">Object</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">mapsto</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">naryObject</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">binder</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">OMI</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// the lexing and checking rule for integer literals, e.g., 1 â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule info.kwarc.mmt.api.objects?OMIâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">OMF</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// the lexing and checking rule for floating point literals â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule info.kwarc.mmt.api.objects?OMFâ™</span><span class="w"></span>
<span class="w">  </span><span class="no">OMSTR</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// the lexing and checking rule for string literals, e.g., &quot;1&quot; â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule info.kwarc.mmt.api.objects?OMSTRâ™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/qmt</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTTypes</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">query</span><span class="w">  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">prop</span><span class="w">   </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">basetp</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">tp</span><span class="w">     </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTQuery</span><span class="w"> </span><span class="p">=</span><span class="w">	</span>
<span class="w">	</span><span class="cm">// Precedence -16xxxxâ™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// &lt;&lt;left&gt;&gt; union|intersection|difference &lt;&lt;right&gt;&gt; â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Union</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 or 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-169000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Intersection</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 and 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-169000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Difference</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 but not 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-169000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">Tuple</span><span class="w"> </span><span class="p">#</span><span class="s"> (* 1,â€¦ *) </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Projection</span><span class="w"> </span><span class="p">#</span><span class="s">  L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// binders â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Let</span><span class="w"> </span><span class="p">#</span><span class="s"> let V1 := 2 in 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-168000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Mapping</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 map V1 *=&gt;* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-168000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">BigUnion</span><span class="w"> </span><span class="p">#</span><span class="s"> &lt;* 3 | V1 in 2 *&gt; </span><span class="k">prec</span><span class="w"> </span><span class="mi">-168000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Comprehension</span><span class="w"> </span><span class="p">#</span><span class="s"> {* V1 in 2 | 3 *} </span><span class="k">prec</span><span class="w"> </span><span class="mi">-168000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// select [from &lt;&lt;start&gt;&gt; until &lt;&lt;end&gt;&gt;]|&lt;&lt;index&gt;&gt; of &lt;&lt;query&gt;&gt;â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Slice</span><span class="w"> </span><span class="p">#</span><span class="s"> select from L1 until L2 of 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160004</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">SliceFrom</span><span class="w"> </span><span class="p">#</span><span class="s"> select from L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160003</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">SliceUntil</span><span class="w"> </span><span class="p">#</span><span class="s"> select until L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160002</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Element</span><span class="w"> </span><span class="p">#</span><span class="s"> select L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160001</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// component|subobject &lt;&lt;spec&gt;&gt; of &lt;&lt;query&gt;&gt;â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Component</span><span class="w"> </span><span class="p">#</span><span class="s"> component L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">SubObject</span><span class="w"> </span><span class="p">#</span><span class="s"> subobject L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">I</span><span class="w"> </span><span class="p">#</span><span class="s"> use L1 for 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Closure</span><span class="w"> </span><span class="p">#</span><span class="s"> closure of 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Singleton</span><span class="w"> </span><span class="p">#</span><span class="s"> {* 1 *} </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// related to &lt;&lt;query&gt;&gt; by &lt;&lt;relation&gt;&gt;â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Related</span><span class="w"> </span><span class="p">#</span><span class="s"> related to 1 by 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// leaf case â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Literal</span><span class="w"> </span><span class="p">#</span><span class="s"> literal 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Literals</span><span class="w"> </span><span class="p">#</span><span class="s"> literals 1,â€¦ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Paths</span><span class="w"> </span><span class="p">#</span><span class="s"> paths 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">QueryFunctionApply</span><span class="w"> </span><span class="p">#</span><span class="s"> function L1 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTJudgements</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// Precedence -15xxxxâ™</span><span class="w"></span>
<span class="w">		</span>
<span class="w">	</span><span class="cm">/T Equality of two terms â™</span><span class="w"> </span>
<span class="w">	</span><span class="no">Equals</span><span class="w"> </span><span class="p">#</span><span class="s"> V1 2 *==* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-150000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T One type has a specific term â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Types</span><span class="w"> </span><span class="p">#</span><span class="s"> V1 2 *:* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-150000</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTProp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// Precedence -14xxxxâ™</span><span class="w">	</span>

<span class="w">	</span><span class="cm">/T unary type relation â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsA</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 isa L2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T ancestor relation between paths â™</span><span class="w"></span>
<span class="w">	</span><span class="no">PrefixOf</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *&lt;&lt;* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T element relation between elements and sets â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsIn</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 contains 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T emptiness of a set â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsEmpty</span><span class="w"> </span><span class="p">#</span><span class="s"> empty 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T equality of elements â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Equal</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *=* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T negation â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Not</span><span class="w"> </span><span class="p">#</span><span class="s"> *!* 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T And â™</span><span class="w"></span>
<span class="w">	</span><span class="no">And</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *&amp;&amp;* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T Or â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Or</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *||* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T Forall â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Forall</span><span class="w"> </span><span class="p">#</span><span class="s"> forall V1 in 2 *.* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T Exists â™</span><span class="w"> </span>
<span class="w">	</span><span class="no">Exists</span><span class="w"> </span><span class="p">#</span><span class="s"> exists V1 in 2 *.* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T Holds â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Holds</span><span class="w"> </span><span class="p">#</span><span class="s"> holds 1 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">â™</span><span class="w"> </span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTRelationExp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// Precedence -13xxxxâ™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T base case: an atomic binary relation â™</span><span class="w"></span>
<span class="w">	</span><span class="no">ToObject</span><span class="w"> </span><span class="p">#</span><span class="s"> object 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T base case: the inverse of an atomic binary relation â™</span><span class="w"></span>
<span class="w">	</span><span class="no">ToSubject</span><span class="w"> </span><span class="p">#</span><span class="s"> subject 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the transitive closure of a relation â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Transitive</span><span class="w"> </span><span class="p">#</span><span class="s"> *+ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the symmetric closure of a relation â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Symmetric</span><span class="w"> </span><span class="p">#</span><span class="s"> symmetric 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">â™</span><span class="w"> </span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the union of a list of relations â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Choice</span><span class="w"> </span><span class="p">#</span><span class="s"> choice 1,â€¦ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the composition of a list of relations â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Sequence</span><span class="w"> </span><span class="p">#</span><span class="s"> sequence 1,â€¦ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the reflexive relation â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Reflexive</span><span class="w"> </span><span class="p">#</span><span class="s"> reflexive 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the reflexive relation restricted to a set of paths â™</span><span class="w"></span>
<span class="w">	</span><span class="no">HasType</span><span class="w"> </span><span class="p">#</span><span class="s"> hastype 1,â€¦ *--* 2,â€¦ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTBinaries</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// Precedence -12xxxxâ™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">DependsOn</span><span class="w"> </span><span class="p">#</span><span class="s"> dependson </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">HasMeta</span><span class="w"> </span><span class="p">#</span><span class="s"> hasmeta </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Includes</span><span class="w"> </span><span class="p">#</span><span class="s"> includes </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">HasDomain</span><span class="w"> </span><span class="p">#</span><span class="s"> hasdomain </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">HasCodomain</span><span class="w"> </span><span class="p">#</span><span class="s"> hascodomain </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsInstanceOf</span><span class="w"> </span><span class="p">#</span><span class="s"> isinstanceof </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">RefersTo</span><span class="w"> </span><span class="p">#</span><span class="s"> refers </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">Declares</span><span class="w"> </span><span class="p">#</span><span class="s"> declares </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsAliasFor</span><span class="w"> </span><span class="p">#</span><span class="s"> isaliasfor </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsAlignedWith</span><span class="w"> </span><span class="p">#</span><span class="s"> isalignedwith </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTUnaries</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// Precedence -12xxxxâ™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">IsDocument</span><span class="w"> </span><span class="p">#</span><span class="s"> document </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsTheory</span><span class="w"> </span><span class="p">#</span><span class="s"> theory </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsView</span><span class="w"> </span><span class="p">#</span><span class="s"> view </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsStructure</span><span class="w"> </span><span class="p">#</span><span class="s"> structure </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsConstant</span><span class="w"> </span><span class="p">#</span><span class="s"> constant </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsPattern</span><span class="w"> </span><span class="p">#</span><span class="s"> pattern </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsInstance</span><span class="w"> </span><span class="p">#</span><span class="s"> instance </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsDerivedDeclaration</span><span class="w"> </span><span class="p">#</span><span class="s"> deriveddeclaration </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsConAss</span><span class="w"> </span><span class="p">#</span><span class="s"> conass </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsStrAss</span><span class="w"> </span><span class="p">#</span><span class="s"> strass </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">IsNotation</span><span class="w"> </span><span class="p">#</span><span class="s"> notation </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTLiterals</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// TODO: Literals â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QMT</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// include the MMT base in notations</span>
<span class="cm">	include ?mmt â™</span><span class="w"></span>

<span class="w">	</span><span class="cm">// TODO: Precedence â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTQuery </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTProp </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTRelationExp </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTJudgements </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTUnaries </span><span class="p">â™</span><span class="w"> </span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTBinaries </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTLiterals </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTTypes </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://quotation.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="cm">/T   introduces a primitive type that exposes the type MMT terms of the underlying implementation</span>
<span class="cm">This can be seen as a first step towards MMT meta-programming but is used here only to represent quotations.</span>
<span class="cm">âš</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">TermLiterals</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?TermsTypesKinds</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T the type of MMT terms â™</span><span class="w"></span>
<span class="w">  </span><span class="no">termliteral</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T makes all MMT terms (inlcudings ill-typed or ill-scoped ones) literals of type $termliteral$â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TermLiteralRule</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">/T   the language features of quotation</span>
<span class="cm">This allows quoting terms that are well-typed in the current context.</span>

<span class="cm">The concrete syntax uses MMT&#39;s string interpolation feature with the identifier q, i.e., q&quot;t&quot; is the quotation of the term t.</span>
<span class="cm">Quoted terms are unevaluated, i.e., q&quot;1+1&quot; != q&quot;2&quot;. </span>

<span class="cm">Within t, it is allowed to escape back into evaluated terms: q&quot;1+${s}&quot; is the quasiquotation q&quot;1+e&quot; where e is the result of evaluating s.</span>
<span class="cm">âš</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Quotation</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">â™</span><span class="w"> </span><span class="cm">// LF is not actually needed here. But due a current bug, the comments are not type-checked correctly without LF. â™</span><span class="w"></span>

<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?TermLiterals</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T For any [a:type], $Q a$ is the type of quotations of terms of type $a$.â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Quote</span><span class="w"> </span><span class="p">#</span><span class="s"> Q 1</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T the quotation operator</span>
<span class="cm">     Because of interpolation, this is not a unary operator - instead, the evaluated subterms are replaced with free variables and bundled up in a substitution.</span>
<span class="cm">     For example, q&quot;1+${s}+2&quot; is internally represented as quote(l, x/s) where l is the term literal 1+x+2.â™</span><span class="w"></span>
<span class="w">  </span><span class="no">quote</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T the evaluation operator: For [a:type, q: Q a], $eval q$ is the evaluation of $q$ of type $a$.â™</span><span class="w"></span>
<span class="w">  </span><span class="no">eval</span><span class="w"> </span><span class="p">#</span><span class="s"> eval 1</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T the concrete syntax for quotations (using string interpolation)â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Lexer</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T the formation rule: For [a:type], $Q a$ is a type.â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteFormation</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the introduction rule: In the simplest case, for [a:type, t:a], the quotation of $t$ has type $Q a$.â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteIntroduction</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the elimination rule: For [a:type, q: Q a], $eval q$ has type $a$.â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteElimination</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the type checking rule: For [a:type], we check [q: Q a] by checking that $eval q$ has type $a$.â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteTyping</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the beta-style reduction rule: For [a:type,t:a] the evaluation of the quotation $t$ reduces to $t$.â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EvalQuote</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T an auxiliary rule for normalizing quotations:</span>
<span class="cm">     For example, it reduces q&quot;1+${q&quot;2&quot;}&quot; to q&quot;1+2&quot;.â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ReduceQuote</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">/T   LF with quotationâš</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFQ</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Quotation</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">/T   a simple test theory âš</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QuotingInterpolationExample</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LFQ</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">a</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">c</span><span class="p">:</span><span class="w"> </span><span class="s">a</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">f</span><span class="p">:</span><span class="w"> </span><span class="s">a âŸ¶ a âŸ¶ a</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">t</span><span class="p">:</span><span class="w"> </span><span class="s">Q a âŸ¶ Q a</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[q] q</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">q1</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c c&quot;</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">q2</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c ${q1}&quot;</span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">q3</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c ${t q1}&quot;</span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">q4</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c ${t q&quot;f c c&quot;}&quot;</span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">q5</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c ${t q&quot;f c ${t q1}&quot;}&quot;</span><span class="p">â™</span><span class="w"> </span>
<span class="p">âš</span><span class="w"></span>

<span class="kn">namespace</span><span class="w"> </span><span class="s">examples/Quotation</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ExcludedMiddle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">/urtheories?LFQ</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">bool</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">ded</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ type</span><span class="p">â˜#</span><span class="s"> âŠ¦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">disj</span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ bool âŸ¶ bool</span><span class="p">â˜#</span><span class="s"> 1 âˆ¨ 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">not</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ bool</span><span class="p">â˜#</span><span class="s"> Â¬ 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">em</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{f} âŠ¦ (eval f) âˆ¨ Â¬ (eval f)</span><span class="p">â™</span><span class="w"> </span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">PeanoInduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">/urtheories?LFQ</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?ExcludedMiddle</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">nat</span><span class="p">:</span><span class="w">  </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">zero</span><span class="p">:</span><span class="w"> </span><span class="s">nat</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">succ</span><span class="p">:</span><span class="w"> </span><span class="s">nat âŸ¶ nat</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">induction</span><span class="p">:</span><span class="w"> </span><span class="s">{f} âŠ¦ (eval f) zero âŸ¶ ({n} âŠ¦ (eval f) n âŸ¶ âŠ¦ (eval f) (succ n)) âŸ¶ ({n} âŠ¦(eval f) n)</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Scala</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">hasType</span><span class="w"> </span><span class="p">#</span><span class="s"> : 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Any</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Unit</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">unit</span><span class="w">     </span><span class="p">#</span><span class="s"> ()</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Product</span><span class="w">  </span><span class="p">#</span><span class="s"> Product [ 1,â€¦ ] </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Tuple</span><span class="w">    </span><span class="p">#</span><span class="s"> Tuple [ 1,â€¦ ]</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Function</span><span class="w"> </span><span class="p">#</span><span class="s"> Fun [ 1,â€¦ ] 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Lambda</span><span class="w">   </span><span class="p">#</span><span class="s"> ( V1T,â€¦ ) -2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000010</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">List</span><span class="w">     </span><span class="p">#</span><span class="s"> List [ 1 ] </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">list</span><span class="w">     </span><span class="p">#</span><span class="s"> List ( 1,â€¦ )</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">BigInt</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Double</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Boolean</span><span class="p">â™</span><span class="w">            </span>
<span class="w">  </span><span class="no">String</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ScalaOM</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Scala</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Term</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Context</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://semiformal.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Informal</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">informal</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InformalLiterals</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InformalTyping</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Semiformal</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Informal</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">semiformal</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SemiformalInterpolation</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SemiformalTerm</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SemiformalInterpolationExample</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Semiformal</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">nat</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">plus</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat âŸ¶ nat âŸ¶ nat</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 + 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">test</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat âŸ¶ nat âŸ¶ nat </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] sf&quot;the sum of all number from 1 to ${x+y}&quot;:nat</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">test2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] sf&quot;the product of ${x+y:nat} and ${y+x:nat}&quot;:nat</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">  </span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://sequences.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Sequences</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Typed</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Nat</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">rep</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ^ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-20</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NTypeTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UniverseNType</span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="no">ellipsis</span><span class="w">  </span><span class="p">#</span><span class="s"> âŸ¨&#39; 2 | V1T &#39;âŸ© </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10002</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">index</span><span class="w">     </span><span class="p">#</span><span class="s"> 1 .. 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">9998</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">flatseq</span><span class="w">   </span><span class="p">#</span><span class="s"> âŸ¨ 1,â€¦ âŸ© </span><span class="k">prec</span><span class="w"> </span><span class="mi">0</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">foldLeft</span><span class="w"> </span><span class="p">#</span><span class="s"> foldL 1 2 3 4 </span><span class="p">â™</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EllipsisInfer</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EllipsisTypeCheck</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EllipsisEqualityCheck</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EllipsisInjective</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RepTypeCheck</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RepEqualityCheck</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ExpandRep</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IndexInfer</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IndexCompute</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FlatseqInjective</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SolveArity</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LengthAwareApplyTerm</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LengthAwareBeta</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FoldLeftType </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFS</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?DHOL</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Sequences</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FlexaryPi</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FlexaryLambda</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FlexaryApply</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Strings</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">empty</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">concat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">string âŸ¶ string âŸ¶ string</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 + 2</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/lf?Realize string rules/api/uom?StandardString</span><span class="p">â™</span><span class="w">  </span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/lf?Realize empty rules/api/uom?StringOperations/Empty</span><span class="p">â™</span><span class="w">  </span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/lf?Realize concat rules/api/uom?StringOperations/Concat</span><span class="p">â™</span><span class="w">  </span>

<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/literals?StandardStringInterpolation string concat</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">StringInterpolationExample</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?Strings</span><span class="w"> </span><span class="p">=</span><span class="w"></span>

<span class="w">  </span><span class="no">c</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">f</span><span class="p">:</span><span class="w"> </span><span class="s">string âŸ¶ string âŸ¶ string</span><span class="p">â˜=</span><span class="w"> </span><span class="s">[x,y] x + y</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">q1</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA&quot;</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">q2</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA ${q1}&quot;</span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">q3</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA ${s&quot;a&quot; + s&quot;b&quot;}&quot;</span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">q4</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA ${f c s&quot;BB&quot;}&quot;</span><span class="p">â™</span><span class="w"> </span>
<span class="w">  </span><span class="no">q5</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA ${f c s&quot;BB ${f q1 q1}&quot;}&quot;</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://substructural.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="cm">// This theory is under development.</span>
<span class="cm">Its goal is to investigate to what extent substructural languages can be represented in MMT.</span>
<span class="cm">This was motivated by a promising initial case study on representing ordered linear logic (done with Jeff Polakow, at LFMTP 2017).âš</span><span class="w"></span>

<span class="cm">//   theory Substructural =</span>
<span class="cm">   Sarrow  # 2 - 1 -&gt; 3  prec  -9990â™</span>
<span class="cm">   Slambda # [ 1 V2T,â€¦ ] 2 prec -10000â™</span>
<span class="cm">   Sapply  # 1%wâ€¦        prec -10â™</span>

<span class="cm">   class # class 1 2  prec 1000â™</span>

<span class="cm">   unordered â™</span>
<span class="cm">   leftordered â™</span>
<span class="cm">   rightordered â™</span>
<span class="cm">   </span>
<span class="cm">   plainâ™</span>
<span class="cm">   useallâ™</span>
<span class="cm">   useonceâ™</span>
<span class="cm">   linearâ™</span>

<span class="cm">   rule rules?SArrowTermâ™</span>
<span class="cm">   rule rules?SLambdaTermâ™</span>
<span class="cm">   rule rules?SApplyTermâ™</span>
<span class="cm">   rule rules?SArrowTypingâ™</span>
<span class="cm">   rule rules?SArrowEqualityâ™</span>
<span class="cm">   rule rules?SArrowBetaâ™</span>
<span class="cm">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="cm">//   LF as meta-theory means using LF HOASâš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Subtyping</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">subtype</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: type, B: type} type                  </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 âŠ†â€ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9980</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">refl</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{A} A âŠ†â€ A</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">trans</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B,C} A âŠ†â€ B âŸ¶ B âŠ†â€ C âŸ¶ A âŠ†â€ C</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">covariant</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: type, B1: A âŸ¶ type, B2: A âŸ¶ type} ({x:A} B1 x âŠ†â€ B2 x) âŸ¶ ({x:A} B1 x) âŠ†â€ ({x:A} B2 x)</span><span class="p">â™</span><span class="w"> </span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Inhabitation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">// &quot;! A&quot; is a judgments for the inhabitation (= non-emptiness) of &quot;A&quot;.</span>
<span class="cm">     If &quot;A&quot; is empty, so is &quot;!A&quot;. If &quot;A&quot; is non-empty, &quot;!A&quot; is a singleton.</span>
<span class="cm">     These types are useful when using proofs as judgments as guards, i.e., in situations where only the inhabitation of a type matters, not the choice of inhabitant.</span>
<span class="cm">     Also note, that if &quot;A&quot; is a type of proofs, then &quot;! A&quot; is essentially the same type but with proof irrelevance.   </span>
<span class="cm">  â™</span><span class="w"></span>
<span class="w">  </span><span class="no">Inh</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">type âŸ¶ type                     </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ! 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Judgment</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// introduction: If we have an inhabitant of &quot;A&quot;, then &quot;A&quot; is inhabited.</span>

<span class="cm">     This is similar to modal logic&#39;s necessitation rule, but we apply it even if there are unboxed assumptions in the context.</span>
<span class="cm">  â™</span><span class="w"></span>
<span class="w">  </span><span class="no">inh</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{A} A âŸ¶ !A </span><span class="p">â˜#</span><span class="s"> inh 2</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// The inverse operator does not exist exactly but almost: If we have &quot;!A&quot;, we can assume an &quot;x:A&quot; as long as we only use &quot;x&quot; to prove other &quot;!B&quot;-judgments.</span>
<span class="cm">  </span>
<span class="cm">  More generally, the declarations in this theory only return !-types.</span>
<span class="cm">  Thus, adding this theory does not affect the adequacy of an existing encoding.â™</span><span class="w"></span>
<span class="w">  </span><span class="no">elim</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{A, B} !A âŸ¶ (A âŸ¶ !B) âŸ¶ !B</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// The operator &quot;inh&quot; is functorial. â™</span><span class="w"></span>
<span class="w">  </span><span class="cm">// Note that this is also the modal axiom K â™</span><span class="w"></span>
<span class="w">  </span><span class="no">K</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} !(A âŸ¶ B) âŸ¶ !A âŸ¶ !B</span><span class="p">â˜</span><span class="w"></span>
<span class="w">         </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B] [p,q] elim p [r: A âŸ¶ B] elim q [s: A] inh (r s)</span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Thus, we have: &quot;A âŸ¶ B&quot; is stronger than &quot;!(A âŸ¶ B)&quot; is stronger than &quot;!A âŸ¶ !B&quot; (which is equivalent to &quot;A âŸ¶ !B&quot;).</span>
<span class="cm">     Set-theoretically, all 3 are equivalent, but proving the inverse directions requires non-canonically choosing an element, which we cannot do in type theory. â™</span><span class="w"></span>
<span class="w">         </span>
<span class="w">  </span><span class="cm">// We can prove that multiple inhabitation operators are redundant.â™</span><span class="w"></span>
<span class="w">  </span><span class="no">idempotent</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} !!A âŸ¶ !A </span><span class="p">â˜</span><span class="w"></span>
<span class="w">         </span><span class="p">=</span><span class="w"> </span><span class="s">[A][p] elim p [a]a</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// operationalizes the rule {A, P:!A, Q:!A} P = Qâ™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/inhabitation?ProofIrrelevance</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">// an experimental theory for predicate subtypesâš</span><span class="w"></span>
<span class="cm">//   theory PredicateSubtypes : ?PLF =</span>
<span class="cm">  include ?Subtypingâ™</span>
<span class="cm">  include ?Inhabitationâ™</span>
<span class="cm">  </span>
<span class="cm">  Sub    : {A: type} (A âŸ¶ type) âŸ¶ type              â˜ # 1 | 2 prec 20â™</span>
<span class="cm">  sub    : {A, P} {x: A} !(P x) âŸ¶ A|P               â˜ # 3 by 4â™</span>

<span class="cm">  subA_A    : {A,P} A|P âŠ†â€ Aâ™</span>
<span class="cm">  subA_subA : {A,P,Q} ({x} P x âŸ¶ Q x) âŸ¶ A|P âŠ†â€ A|Qâ™</span>

<span class="cm">  // elim   : {A,P}{x: A|P} ! (P x)â™</span>
<span class="cm">  // sub x (elim x) = xâ™</span>
<span class="cm">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories/reflection</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Terms</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">/urtheories?Typed</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">formation</span><span class="w"> </span><span class="p">#</span><span class="s"> {| 1 |} 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">reflect</span><span class="w">   </span><span class="p">#</span><span class="s"> âŒœ 1 : 2 âŒ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">eval</span><span class="w">      </span><span class="p">#</span><span class="s"> âŒ 1 âŒŸ 2   </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">â™</span><span class="w"></span>
<span class="w">   </span><span class="no">elim</span><span class="w">      </span><span class="p">#</span><span class="s"> 1 ^ 2     </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFReflection</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">/urtheories?LF</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Terms</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">lf</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Bool</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?TermsTypesKinds </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">BOOL</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">TRUE</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">BOOL</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">FALSE</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">BOOL</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Ded</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Bool </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">DED</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">BOOL âŸ¶ type</span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> DED 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">â˜</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Judgment</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">lf?TermIrrelevanceRule (DED)</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">lf?PiIrrelevanceRule </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">TRUEI</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">DED TRUE</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="cm">//   dependently-typed higher-order logic, i.e., LF with booleans and equalityâš</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">DHOL</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Ded </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">EQUAL</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a:type} a âŸ¶ a âŸ¶ BOOL </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 EQ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">NOTEQUAL</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a:type} a âŸ¶ a âŸ¶ BOOL </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 NEQ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">CONTRA</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â˜=</span><span class="w"> </span><span class="s">DED FALSE</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="cm">// if : {a:type} bool âŸ¶ a âŸ¶ a âŸ¶ aâ™</span><span class="w"></span>

<span class="w">  </span><span class="no">REFL</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{A,X:A} DED X EQ X  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">SYM</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{A,X:A,Y} DED X EQ Y âŸ¶ DED Y EQ X </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">TRANS</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,X:A,Y,Z} DED X EQ Y âŸ¶ DED Y EQ Z âŸ¶ DED X EQ Z </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">CONG</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A, B, F: A âŸ¶ B, X, Y: A} DED X EQ Y âŸ¶ DED (F X) EQ (F Y)</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">DHOL2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">bool</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">equal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type} A âŸ¶ A âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 â‰ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">ded</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">bool âŸ¶ type </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âŠ¦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">refl</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{A,X:A} âŠ¦ X â‰ X </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> refl %I1 %I2 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">cong</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A, B: type} {F: A âŸ¶ B} {X, Y: A} âŠ¦ X â‰ Y âŸ¶ âŠ¦ (F X) â‰ (F Y) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> congI 3 6 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type,B:A âŸ¶ type}{F:{x:A} B x, G:{x:A} B x} ({x: A} âŠ¦ F x â‰ G x) âŸ¶ âŠ¦ F â‰ G </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> ext 5 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">eqDed</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{B1,B2:bool} âŠ¦ B1 â‰ B2 âŸ¶ âŠ¦ B1 âŸ¶ âŠ¦ B2 </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> eqded 3 4</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">eqI</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{B1,B2:bool} (âŠ¦ B1 âŸ¶ âŠ¦ B2) âŸ¶ (âŠ¦ B2 âŸ¶ âŠ¦ B1) âŸ¶ âŠ¦ (B1 â‰ B2) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> eqI 3 4 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">symmetry</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : type}{a,b : A} âŠ¦ a â‰ b âŸ¶ âŠ¦ b â‰ a </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A][a,b][p] eqded (congI ([x] x â‰ a) p) refl </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> symm 4 </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">eqFun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : type,B : type}{F,G : A âŸ¶ B} âŠ¦ F â‰ G âŸ¶ {a} âŠ¦ F a â‰ G a </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B][F,G][p][a] congI ([H: A âŸ¶ B] H a) p </span><span class="p">â˜#</span><span class="s"> eqfun 5 6 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">([x:bool] x) â‰ ([x:bool] x) </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">trueI</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">âŠ¦ true </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">refl </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">forall</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type} (A âŸ¶ bool) âŸ¶ bool </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P] P â‰ ([x:A] true) </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> âˆ€ 2 </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">forallI</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type, P : A âŸ¶ bool}({x} âŠ¦ P x) âŸ¶ âŠ¦ âˆ€[x] P x </span><span class="p">â˜</span><span class="w"></span>
<span class="w">    </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P][p] ext ([x: A] eqI ([pf: âŠ¦ P x] trueI) ([pt: âŠ¦ true] p x)) </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">forallE</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type, P : A âŸ¶ bool} (âŠ¦ âˆ€[x]P x) âŸ¶ {a} âŠ¦ P a </span><span class="p">â˜</span><span class="w"></span>
<span class="w">    </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P][p][a] eqded (eqfun (symm p) a) trueI </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatSymbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?TermsTypesKinds </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">NAT</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">â™</span><span class="w"></span>
<span class="w">	</span><span class="no">zero</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">NAT </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatArith</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatSymbols </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">succ</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">NAT âŸ¶ NAT      </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">one</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">NAT             </span><span class="p">â˜</span><span class="w"></span>
<span class="w">        </span><span class="p">=</span><span class="w"> </span><span class="s">succ zero           </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">plus</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">NAT âŸ¶ NAT âŸ¶ NAT </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">times</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">NAT âŸ¶ NAT âŸ¶ NAT </span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatRels</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?Ded</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatArith </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">LEQ</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">NAT âŸ¶ NAT âŸ¶ BOOL </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 LEQ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">LESS</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">NAT âŸ¶ NAT âŸ¶ BOOL </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 LESS 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">â˜</span><span class="w"></span>
<span class="w">        </span><span class="p">=</span><span class="w"> </span><span class="s">[m,n] (succ m) LEQ n</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">REFL</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{n} DED n LEQ n</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatRules</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?DHOL</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatRels </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">eq_leq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X EQ Y âŸ¶ DED Y LEQ Z âŸ¶ DED X LEQ Z  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">leq_eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y âŸ¶ DED Y EQ Z âŸ¶ DED X LEQ Z  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">plus_comm</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED plus X Y EQ plus Y X  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_assoc</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED plus (plus X Y) Z EQ plus X (plus Y Z) </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_neut_Ex</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED plus X zero EQ X </span><span class="p">â˜</span><span class="w"> </span><span class="p">#</span><span class="s"> %%prefix 0 1</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_neut</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED plus X zero EQ X </span><span class="p">â˜</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[X] plus_neut_Ex X </span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">plus_succ_R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED plus X (succ Y) EQ succ (plus X Y)</span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_succ_L</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED plus (succ X) Y EQ succ (plus X Y) </span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">times_comm</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED times X Y EQ times Y X  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">times_assoc</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED times (times X Y) Z EQ times X (times Y Z)  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">times_neut</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED times X one EQ X</span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">times_zero</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED times X zero EQ zero</span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">times_succ_R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED times X (succ Y) EQ plus (times X Y) X</span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">times_succ_L</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED times (succ X) Y EQ plus (times X Y) X</span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="no">distrib</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED times X (plus Y Z) EQ plus (times X Y) (times X Z) </span><span class="p">â˜</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">leq_refl</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED X LEQ X  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">leq_trans</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y âŸ¶ DED Y LEQ Z âŸ¶ DED X LEQ Z    </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">leq_antisym</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED X LEQ Y âŸ¶ DED Y LEQ X âŸ¶ DED X EQ Y      </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">plus_mono</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y âŸ¶ DED (plus X Z) LEQ (plus Y Z)  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_mono_L</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y âŸ¶ DED (plus Z X) LEQ (plus Z Y)  </span><span class="p">â˜</span><span class="w"> </span>
<span class="w">                </span><span class="p">=</span><span class="w"> </span><span class="s">[X,Y,Z,p] leq_eq (eq_leq plus_comm (plus_mono p)) plus_comm</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_invmono</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED (plus X Z) LEQ (plus Y Z) âŸ¶ DED X LEQ Y  </span><span class="p">â™</span><span class="w"></span>

<span class="w">  </span><span class="kd">theory</span><span class="w"> </span><span class="nv">NatOnly</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?DHOL</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="no">least</span><span class="w">         </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED zero LEQ X </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">plus_larger_L</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED X LEQ (plus X Y)  </span><span class="p">â˜</span><span class="w"></span>
<span class="w">                  </span><span class="p">=</span><span class="w"> </span><span class="s">[X][Y] eq_leq (SYM plus_neut) (plus_mono_L least)  </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">plus_larger_R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED Y LEQ (plus X Y)  </span><span class="p">â˜</span><span class="w"></span>
<span class="w">                  </span><span class="p">=</span><span class="w"> </span><span class="s">[X][Y] leq_eq plus_larger_L plus_comm</span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">times_mono</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y âŸ¶ DED (times X Z) LEQ (times Y Z)  </span><span class="p">â™</span><span class="w"></span>
<span class="w">    </span><span class="no">times_invmono</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED (times X Z) LEQ (times Y Z) âŸ¶ DED X LEQ Y  </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="p">âš</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uom</span><span class="w"> </span><span class="s">scala://uom.api.mmt.kwarc.info</span><span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatLiteralsOnly</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatSymbols </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Realize NAT uom?StandardNat</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Realize zero uom?Arithmetic/Zero</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
<span class="w">    </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">NatLiterals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatLiteralsOnly </span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatArith</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Realize one uom?Arithmetic/One</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Realize succ uom?Arithmetic/Succ</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Nat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?DHOL</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatSymbols</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatRules</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatRules/NatOnly</span><span class="p">â™</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatLiterals</span><span class="p">â™</span><span class="w"></span>
<span class="p">âš</span><span class="w"></span>
</pre></div>
</body></html>